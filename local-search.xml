<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Transformer杂记</title>
    <link href="/transformer-9682692f6aa3/"/>
    <url>/transformer-9682692f6aa3/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在Transformer出现之前，NLP的通解经历了几种架构的变迁：</p><ul><li><p>第一阶段：混沌、机械的统计机器学习为代表的方法。</p></li><li><p>第二阶段：以word2vec为代表的方法。</p></li><li><p>第三阶段：以bert为代表的方法。</p></li></ul><p>第一阶段中，NLP对于每一个序列中的元素表示没有一个统一的方法。据我了解的方法就有如下：</p><ul><li>one-hot表示一个词</li><li>bag-of-words来表示一段文本</li><li>tf-idf中用频率的手段来表征词语的重要性</li><li>text-rank中借鉴了page-rank的方法来表征词语的权重</li><li>基于SVD纯数学分解词文档矩阵的LSA</li><li>pLSA中用概率手段来表征文档形成过程</li><li>LDA中引入两个共轭分布从而完美引入先验</li></ul><blockquote><p>仅需要关注前三个即可，第四个开始其实业界研究、使用都比较少了，但作为一种思想可以学习。</p></blockquote><p>第二阶段是技术积累阶段。【TODO】</p><p>第三阶段则是现在大航海的阶段。现在的大家说起大模型第一个想到的就是OpenAI提出的GPT，它开启了大规模语料集预训练模型的时代。GPT其实是“Improving Language Understanding by Generative Pre-Training”这篇论文中的Generative Pre-Traning的缩写。这篇论文中使用的核心技术则是谷歌在2017年提出的Transformer架构，也就是后续我们需要学习的对象。</p><blockquote><p>插个题外话，谷歌和百度这两家在我看来都有一定的相似性。二者都以搜索业发家，并且都具有一定的技术前瞻性，但却没有很好的落地能力。百度早在2013年就开始布局自动驾驶，但今天却难以在自动驾驶的智驾系统中立足；文心一言大模型在历经技术更迭后却不能及时推广出去导致日活越来越低，加上各类负面新闻使得百度成为“起个大早赶个晚集”的代表；谷歌拥有多个行业的技术积累，但却没有深入挖掘落地场景，事实上谷歌的能力并不差：2018年战胜李世石的AlphaGo、深度强化学习的开山之作DQN均诞生于谷歌旗下。这不禁让人思考：技术是否真的是科技行业的一切？</p></blockquote><h2 id="Transformer的感性认知"><a href="#Transformer的感性认知" class="headerlink" title="Transformer的感性认知"></a>Transformer的感性认知</h2><p>Transformer模型提出之始是用于自然语言处理（Natural Language Processing，NLP）任务的，NLP的典型任务类型本质是<strong>语言序列处理</strong>。一个序列是若干语言元素（如单词、标点）的集合，NLP的多数任务是基于这种不定长的输入进行不定长的输出。实际上，语言模型的本质是对一段自然语言的文本进行预测概率的大小，即：<br>$$<br>P(s)&#x3D;P(w_1w_2w_3…w_t) &#x3D;P(w_1)P(w_2|w_1)P(w_3|w_1w_2)P(w_T|w_1…w_{T-1})<br>$$</p><p>另外一个值得关注的Transformer特征就是query 、 key &amp; value 的概念。query 、 key &amp; value 的概念其实来源于推荐系统。基本原理是：给定一个 query，计算query 与 key 的相关性，然后根据query 与 key 的相关性去找到最合适的 value。举个例子：在电影推荐中。query 是某个人对电影的喜好信息（比如兴趣点、年龄、性别等）、key 是电影的类型（喜剧、年代等）、value 就是待推荐的电影。在这个例子中，query, key 和 value 的每个属性虽然在不同的空间，其实他们是有一定的潜在关系的，也就是说通过某种变换，可以使得三者的属性在一个相近的空间中。</p><p>Transformer的结构图是这样的：</p><p><img src="https://pic1.imgdb.cn/item/687606f558cb8da5c8b1da38.png" alt="Transformer 结构"></p><p>它由Encoder编码器和Decoder解码器两个部分组成，并在最后的输出层使用一个全连接层FC以及Softmax来输出对应的概率。</p><h2 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h2><h3 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h3><p>特征嵌入（Embedding）是一个很有意思的特征变换过程。一般来说，他会用在特征尺度不统一的情况下的变换，或者数据的增维、降维。如果时间允许，建议阅读知乎的<a href="https://zhuanlan.zhihu.com/p/164502624">这篇文章</a>。在Transformer的论文中，embedding的尺寸为512维。</p><h3 id="自注意力-Self-Attetnion"><a href="#自注意力-Self-Attetnion" class="headerlink" title="自注意力 Self Attetnion"></a>自注意力 Self Attetnion</h3><p>自注意力计算如下：<br>$$<br>Z(Q,K,V) &#x3D; Softmax(\frac{QK^{T}}{\sqrt{d}})V<br>$$<br>在计算开始前，需要明白如下物理量的意义：</p><ul><li><p>$Q,K,V$ 均为矩阵，其行数为输入序列的长度，其列数为embedding的维度。</p></li><li><p>$d$ 为embedding结果 $X$到QKV的映射矩阵$W_i$的列数，在Transformer的论文中这个值为64。</p></li></ul><blockquote><p>严格来说，这里的64是拆分后的结果。映射矩阵$W_q,W_k,W_v$本身是一个$512\times 512$的矩阵，只不过被按列拆成了8份，每一份的维度列数为512&#x2F;8&#x3D;8.</p></blockquote><p>为了方便说明，我们称$Q$和$K$转置的积为score，最终的注意力计算结果为Z。</p><p>以简单的句子<code>&quot;Going Home&quot;</code>为例，演示其输入后的计算流程。首先先是得到QKV矩阵的流程：<br><img src="https://pic1.imgdb.cn/item/6875b0f558cb8da5c8ae5856.png" alt="前置计算"></p><p>随后则是根据自注意力计算公式进行计算：</p><p><img src="https://pic1.imgdb.cn/item/6875b7ee58cb8da5c8ae830d.png" alt="自注意力计算"></p><h3 id="多头自注意力MultiHead-Attention-MHA"><a href="#多头自注意力MultiHead-Attention-MHA" class="headerlink" title="多头自注意力MultiHead Attention(MHA)"></a>多头自注意力MultiHead Attention(MHA)</h3><p>为了进一步细化自注意力机制层，增加了“多头注意力机制”的概念。 对于多头自注意力机制，则不止有一组Q&#x2F;K&#x2F;V权重矩阵，而是有多组（论文中使用8组），所以每个编码器&#x2F;解码器使用8个“头”（可以理解为8个互不干扰自的注意力机制运算），每一组的Q&#x2F;K&#x2F;V都不相同。然后，得到8个不同的权重矩阵Z，每个权重矩阵被用来将输入向量投射到不同的表示子空间。</p><p>如果硬要公式来表示的话，MHA的计算流程如下：</p><p>$$<br>\begin{aligned}</p><p>&amp;Q_i &#x3D; QW_i^Q,K_i &#x3D; KW_i^K,V_i &#x3D; VW_i^V,\quad where \quad i\in{1,2,\cdots,n}\<br>&amp;head_i &#x3D; Attention(Q_i,K_i,V_i) ,\quad where \quad i\in{1,2,\cdots,n}\<br>&amp;MHA(Q,K,V) &#x3D; Concat(head_1,head_2,\cdots,head_n)\cdot W^o<br>\end{aligned}<br>$$</p><p>在Transformer中使用的是MultiHead Attention，其实这玩意和Self Attention区别并不是很大。先明确以下几点：</p><ol><li>MultiHead的head不管有几个，每个head的参数量都是一样的。并不是head多，参数就多。</li><li>当多头的head数量为1时，并不等价于Self Attetnion，MultiHead Attention和Self Attention是不一样的东西。</li><li>多头注意力使用的也是自注意力计算的公式。</li><li>MultiHead除了 $W_q$, $W_k$, $W_v$ 三个矩阵外，还要多额外定义一个$W_o$。<br>而MultiHead Attention在带入公式前做了一件事情，就是拆，它按照“词向量维度（即将512维度进行拆分）”这个方向，将Q,K,V拆成了多个头，在这里以拆分成四个头为例进行演示，如图所示：<br><img src="https://pic1.imgdb.cn/item/6875cbd358cb8da5c8af624e.png" alt="QKV按列拆分"></li></ol><p>随后进行同样的自注意力计算流程得到四个头对应的Attention值：<br><img src="https://pic1.imgdb.cn/item/6875cc5558cb8da5c8af688a.png"></p><p>这样得到的拆分Attention结果如果直接Concat效果是肯定不太好的，所以最后需要再采用一个额外的Wo矩阵，对Attention再进行一次线性变换。$W_o$其实也可以看作是一次Embedding，用于将不同维度中的信息进行融合。</p><p>注意$W_o$矩阵不需要八个，对于第5节中的案例，两组词向量2x512对应的原始维度为512x512的WQ、WK和WV被拆分为8个512x64的矩阵，故计算后得到8个2x64的Z矩阵，形式类似下图：</p><p><img src="https://pic1.imgdb.cn/item/6875cf2058cb8da5c8af72b3.png"></p><p>只需要把这些注意力结果的$Z$矩阵拼接起来然后用一个额外的权重矩阵Wo与之相乘即可。</p><h3 id="残差结构"><a href="#残差结构" class="headerlink" title="残差结构"></a>残差结构</h3><p>不做详细说明</p><h3 id="Decoder解码器"><a href="#Decoder解码器" class="headerlink" title="Decoder解码器"></a>Decoder解码器</h3><p> 论文中的结构图采用的是Outputs进行表示，其实是整个Transformer上一时刻的输出作为Decoder的输入。具体可以分类为训练时的输入和预测时的输入。</p><p> 训练时：就是对已经准备好对应的target数据（类似CV groundtruth标定）。例如翻译任务，Encoder输入“Tom chase Jerry”，Decoder输入对应的中文翻译标定“汤姆追逐杰瑞”。</p><p> 预测时：预测时Decoder的输入其实按词向量的个数来做循环输入，Decoder首次输入为起始符，然后每次的输入是上一时刻Transformer的输出。例如，Decoder首次输入“”，Decoder输出为本时刻预测结果“汤姆”；然后Decoder输入“汤姆”，Decoder输出预测结果“汤姆追逐”；之后Decoder输入“汤姆追逐”，则输出预测结果“汤姆追逐杰瑞”；最后Decoder输入“汤姆追逐杰瑞”，预测输出“汤姆追逐杰瑞”，此时输入输出一致，则结果整个流程。</p><p> 可以看出，预测阶段的Decoder其实是一个循环推理的过程，为了词的前后关联性，从而根据分词方式来确定时间序列的长度t（Decoder执行的次数）。而前述的Encoder的输出给到Decoder作为输入，其实是Encoder给了Decoder的Multi-Head Attention提供可Keys和Values矩阵。故6个叠加的Decoder中每个注意力均使用同一个Keys和Values矩阵。整个流程可以使用下面的一个流程范例来帮助理解。</p><p>  假设我们是要用Transformer翻译“Machine learning is fun”这句话。首先，我们会将“Machine learning is fun” 送给Encoder，输出一个名叫Memory的Tensor，之后我们会将该Memory作为Decoder的一个输入，使用Decoder预测。Decoder并不是一下子就能把“机器学习真好玩”说出来，而是一个词一个词说（或一个字一个字，这取决于你的分词方式），首次输入起始值<code>&lt;bos&gt;</code>(begin of sentence的缩写)，Decoder根据Memory推理输出“机”字， 紧接着，我们会再次调用Decoder，这次是传入<code>&quot;&lt;bos&gt; 机&quot;</code>，然后推理得到“器”字；依次类推，直到最后输出<code>&lt;eos&gt;</code>结束，当Transformer输出<code>&lt;eos&gt;</code>时，预测就结束了。</p><h3 id="掩码多头注意力-Masked-MultiHead-attention"><a href="#掩码多头注意力-Masked-MultiHead-attention" class="headerlink" title="掩码多头注意力 Masked MultiHead-attention"></a>掩码多头注意力 Masked MultiHead-attention</h3><p>由于解码器采用自回归auto-regressive，即 在过去时刻的输出作为当前时刻的输入，也就是说在预测时无法看到之后的输入输出，但是在注意力机制当中，可以看到完整的输入(每一个词都要和其他词做点积，计算相关性)，为了避免这种情况的发生，在<strong>解码器训练时</strong>，在<strong>预测t时刻的输出时</strong>，不应该能看到t时刻以后的输入。做法是：采用带掩码的Masked注意力机制,从而保证在t时刻无法看到t时刻以后的输入，保证训练和预测时的行为一致性。</p><p>所以，Masked-MultiHead-attention的其它部分计算流程实际上与Encoder中的计算过程一致，区别只是在计算出scores矩阵时对其沿对角线上部分进行mask掩码。其主要在训练阶段屏蔽t时刻之后的输入生效，而在预测阶段其实并没有真实作用。如第10节所举之例，预测“机器学习真好玩”的过程。对于Decoder来说是一个字一个字预测的，所以假设我们Decoder的输入是“机器学习”时，“习”字只能看到前面的“机器学”三个字，所以此时对于“习”字只有“机器学习”四个字的注意力信息。但是，训练阶段传的是“机器学习真好玩”，还是不能让“习”字看到后面“真好玩”三个字，所以要使用mask将其盖住，这又是为什么呢？原因是：训练阶段是为了让每个词只看到序列（因为训练时解码器端输入整个序列）中前面的词，而测试阶段是为了防止编码发生变化。</p><h1 id="mask掩码的方式，原理很简单，self-attention的输出是经过softmax的scores向量，故对应scores屏蔽即可。Decoder是逐个接收输入后进行输出的，那么在t时刻，共有-v-t-个输入向量。那么score矩阵-A-alpha-、输入词向量-V-v-i-0-leq-i-leq-t-以及输出-O-满足如下关系：-begin-bmatrix-o-1-o-2-vdots-o-t-end-bmatrix"><a href="#mask掩码的方式，原理很简单，self-attention的输出是经过softmax的scores向量，故对应scores屏蔽即可。Decoder是逐个接收输入后进行输出的，那么在t时刻，共有-v-t-个输入向量。那么score矩阵-A-alpha-、输入词向量-V-v-i-0-leq-i-leq-t-以及输出-O-满足如下关系：-begin-bmatrix-o-1-o-2-vdots-o-t-end-bmatrix" class="headerlink" title="mask掩码的方式，原理很简单，self-attention的输出是经过softmax的scores向量，故对应scores屏蔽即可。Decoder是逐个接收输入后进行输出的，那么在t时刻，共有$v_t$个输入向量。那么score矩阵$A(\alpha)$、输入词向量$V&#x3D;{v_i|0\leq i\leq t}$以及输出$O$满足如下关系：$$\begin{bmatrix}o_1\o_2\\vdots\o_t\end{bmatrix}"></a>mask掩码的方式，原理很简单，self-attention的输出是经过softmax的scores向量，故对应scores屏蔽即可。Decoder是逐个接收输入后进行输出的，那么在t时刻，共有$v_t$个输入向量。那么score矩阵$A(\alpha)$、输入词向量$V&#x3D;{v_i|0\leq i\leq t}$以及输出$O$满足如下关系：<br>$$<br>\begin{bmatrix}<br>o_1\o_2\\vdots\o_t<br>\end{bmatrix}</h1><p>\begin{bmatrix}<br>\alpha_{1,1} &amp; 0 &amp; \cdots &amp; 0\<br>\alpha_{2,1} &amp; \alpha_{2,2} &amp; \cdots &amp; 0\<br>\vdots &amp;\vdots &amp; \quad &amp; \vdots\</p><p>\alpha_{t,1} &amp; \alpha_{t,2} &amp; \cdots &amp; \alpha_{t,t}<br>\end{bmatrix}<br>\begin{bmatrix}<br>v_1\v_2\\vdots\v_t<br>\end{bmatrix}<br>$$</p><p>也就是说，对矩阵中对角线以上的元素使用0进行遮罩即可，在Transformer的代码中，scores矩阵中的mask掩码并非置0，而是使用了-1e9（负无穷）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> mask <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    scores = scores.masked_fill(mask == <span class="hljs-number">0</span>, -<span class="hljs-number">1e9</span>)<br>p_attn = scores.softmax(dim=-<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这是因为，mask为0的话，注意力矩阵经过softmax中的指数运算后，会在遮罩部分有残留的值。因此应该mask为一个远远小于0的数，例如-1e9。</p><blockquote><p>回忆Softmax函数：$Softmax(X) &#x3D; \frac{e^{x_i}}{\sum_i e^{x_i}}$。对于$x_i&#x3D;0$而言，指数运算后的值并非为0。</p></blockquote><h3 id="最终输出"><a href="#最终输出" class="headerlink" title="最终输出"></a>最终输出</h3><p>Liner和Softmax层将解码器最终输出的实数向量变成一个word，线性变换层是全连接神经网络，将解码器产生的向量投影到一个比它大得多的、被称作对数几率（logits）的向量里。假设模型从训练集中学习一万个不同的word，则对数几率向量为一万个单元格长度的向量，每个单元格对应某一个单词的分数。softmax层将分数变成概率，概率最高的单元格对应的单词被作为该时间的输出。</p><p>仍按前例，如输入一个2x512的词向量矩阵，前述Decoder重复执行6次后得到一个2x64的矩阵，然后进过FC（Linear）线性变换后得到一个1x2的向量，进行最终的softmax评分得到最高分数即为target中某个词的概率。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1] <a href="https://blog.csdn.net/xunan003/article/details/130080111">一文理解Transformer整套流程</a></p>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Transformer</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KVCache初探</title>
    <link href="/KVCache-beeb481dee12/"/>
    <url>/KVCache-beeb481dee12/</url>
    
    <content type="html"><![CDATA[<h2 id="KVCache是什么"><a href="#KVCache是什么" class="headerlink" title="KVCache是什么"></a>KVCache是什么</h2><p>KVcache一句话来说就是把每个token在过Transformer时乘以$W_K$,$W_V$这俩参数矩阵的结果缓存下来。KVCache是针对推理时而言的，训练时KV没必要进行缓存。推理解码生成时都是自回归auto-regressive的方式，也就是每次生成一个token，都要依赖之前token的结果。如果没生成一个token的时候乘以W_K,W_V这俩参数矩阵要对所有token都算一遍，代价非常大，所以缓存起来就叫kvcache。如果每次生成一个token的时候乘以$W_K$,$W_V$这俩参数矩阵要对所有token都算一遍，代价非常大，所以缓存起来就叫kvcache。</p><p>举个例子，假如prompt&#x3D;“The largest city of China is”，输入是6个tokens，返回是”Shang Hai”这两个tokens。整个生成过程如下：</p><ol><li><p>当生成”Shang”之前，kvcache把输入6个tokens都乘以W_K,W_V这两参数矩阵，也就是缓存了6个kv。这时候过self-attention+采样方案(greedy、beam、top k、top p等)，得到”Shang”这个token</p></li><li><p>当生成”Shang”之后，再次过transformer的token只有”Shang”这一个token，而不是整个“The largest city of China is Shang”句子，这时再把”Shang”这一个token对应的kvcache和之前6个tokens对应的kvcache拼起来，成为了7个kvcache。”Shang”这一个token和前面6个tokens就可以最终生成”Hai”这个token。</p></li></ol><h2 id="为什么没有QCache"><a href="#为什么没有QCache" class="headerlink" title="为什么没有QCache"></a>为什么没有QCache</h2><p>为什么不缓存$W_Q$矩阵相乘的结果？一句话来说Q cache并没有用。我们观察自注意力计算公式：</p><p>$$<br>Attention(Q,K,V) &#x3D; Softmax(\frac{QK^T}{\sqrt{d}})V<br>$$</p><p>每次新多一个Q中的token的query时，用新多的这个token和所有tokens的K、V去乘就好了，Q Cache就成多余的了。再拿刚才例子强调一下，当生成”Shang”之后，再次过transformer的token只有”Shang”这一个token，而不是整个“The largest city of China is Shang”句子。</p><p>那么问题就又来了，生成”Shang”这个token时，感觉是“The largest city of China is”这6个tokens的query都用了，但是生成”Hai”这个token时，只依赖了”Shang”这个token的query嘛？这个问题其实是没有的，每个token的生成都只依赖前一个Q和之前所有的KV：</p><p><img src="https://www.omrimallis.com/assets/llama_cpp_kqv_iter.png.webp"></p><p>如图所示【TODO】：</p><ol><li><p>训练的时候计算注意力score时，’Quant’,‘um’,’_mechan’的下一个token在矩阵乘法时对应的是蓝框，已经被mask没了；</p></li><li><p>推理的时候在给定’Quant’,‘um’,’_mechan’的时候，已有的序列长度是3，矩阵乘法是由图中红框决定的，刚好和未来没读到的蓝框token没有任何关系。同时，‘_mechan’的下一个token只和’_mechan’的Q有关，和’Quant’,’um’的Q是无关的。所以每个token的生成都只依赖前一个Q和之前所有的KV，这也是kvcache能work下去的基础。</p></li></ol><p>KV Cache 加速推理的原理是：在自注意力层，本来每次要做矩阵乘法 $\mathbf Q\mathbf K^T$，现在因为 KV Cache 的存在，我们不需要整个 $\mathbf Q$ 和 $\mathbf K^T$ 做矩阵乘法，只需要每次输入的最后一个 token 的 query 向量 $\mathbf q$ 和 $\mathbf K$ 做向量 - 矩阵乘法，之后更新 KV Cache 缓存即可。</p><p>采用了 KV Cache 的话 LLM 的推理过程可以看成 2 个阶段</p><p>第一次迭代的时候，此时 KV Cache 为空，所有的输入的 token 都需要为其计算 key, value, query 向量，其中 key 和 value 会被缓存起来<br>后续的每一次迭代，只需要为新的 token 计算 key、value、query，并更新 KV Cache<br>KV Cache 加速推理的代价是显存占用会变高，所以它是空间换时间的办法，关于开不开 KV Cache 的显存占用峰值的对比可以看 这里。我在这里放一个总结：</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><p><a href="https://blog.csdn.net/taoqick/article/details/137476233">kvcache原理、参数量、代码详解</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/662498827">大模型推理加速：看图学KV Cache</a></p></li><li><p><a href="https://martinlwx.github.io/zh-cn/llm-inference-optimization-kv-cache/">LLM 推理加速 - KV Cache</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LLM</tag>
      
      <tag>Transformer</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebAssembly初探</title>
    <link href="/WASM%E5%88%9D%E6%8E%A2-1b3eecdb0431/"/>
    <url>/WASM%E5%88%9D%E6%8E%A2-1b3eecdb0431/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是WebAssembly"><a href="#什么是WebAssembly" class="headerlink" title="什么是WebAssembly"></a>什么是WebAssembly</h2><p> WebAssembly（简称WASM）是一种可以在网页浏览器中运行的二进制指令格式。它由WebAssembly社区组（W3C的WebAssembly工作组）开发，旨在提供一种高效、安全且跨平台的计算方式，以支持现代Web应用的需求。</p><h3 id="WASM的工作原理"><a href="#WASM的工作原理" class="headerlink" title="WASM的工作原理"></a>WASM的工作原理</h3><ol><li><p><strong>二进制格式</strong>：WASM是一种二进制格式，而不是像JavaScript那样的高级脚本语言。这种二进制格式使得编译器可以将高级语言（如C、C++、Rust等）编译成高效的机器代码，从而提高执行速度。</p></li><li><p><strong>模块化</strong>：WASM模块是独立的、可重用的代码单元，可以包含函数、数据、表和内存等。这些模块可以通过WebAssembly的链接器进行组合，形成更复杂的程序。</p></li><li><p><strong>沙箱环境</strong>：WASM运行在一个沙箱环境中，这意味着它只能访问特定的资源和功能，从而提高安全性。例如，WASM模块不能直接访问用户的文件系统或摄像头。</p></li><li><p><strong>跨平台</strong>：WASM可以运行在任何支持WASM的平台上，包括浏览器、服务器和移动设备。这使得开发者可以使用一种语言编写代码，然后在不同的平台上运行。</p></li></ol><h3 id="WASM的特点"><a href="#WASM的特点" class="headerlink" title="WASM的特点"></a>WASM的特点</h3><p>WebAssembly具有以下几个显著的特点：</p><ol><li><p><strong>高性能</strong>：WASM是二进制格式，这意味着它比传统的脚本语言（如JavaScript）更高效。编译器可以将高级语言代码编译成高效的机器代码，从而提高执行速度。</p></li><li><p><strong>安全</strong>：WASM运行在一个沙箱环境中，这意味着它只能访问特定的资源和功能。这种沙箱环境可以防止WASM模块执行恶意代码，从而提高安全性。</p></li><li><p><strong>跨平台</strong>：WASM可以运行在任何支持WASM的平台上，包括浏览器、服务器和移动设备。这使得开发者可以使用一种语言编写代码，然后在不同的平台上运行。</p></li><li><p><strong>模块化</strong>：WASM模块是独立的、可重用的代码单元，可以包含函数、数据、表和内存等。这些模块可以通过WebAssembly的链接器进行组合，形成更复杂的程序。</p></li><li><p><strong>低延迟</strong>：由于WASM是二进制格式，因此它可以减少网络传输的开销，从而提高应用的响应速度。</p></li><li><p><strong>丰富的生态系统</strong>：WASM有一个活跃的社区和丰富的生态系统，包括编译器、工具链、库和框架等。这使得开发者可以轻松地使用WASM进行开发。</p></li><li><p><strong>兼容性</strong>：WASM可以与现有的Web技术（如HTML、CSS和JavaScript）无缝集成，从而使得开发者可以使用WASM来扩展和优化现有的Web应用。</p></li></ol><h3 id="WASM的应用场景"><a href="#WASM的应用场景" class="headerlink" title="WASM的应用场景"></a>WASM的应用场景</h3><ol><li><p><strong>高性能计算</strong>：WASM可以用于运行高性能计算任务，如游戏、视频编辑、数据分析等。由于WASM可以将高级语言编译成高效的机器代码，因此在这些场景中可以实现更好的性能。</p></li><li><p><strong>游戏开发</strong>：WASM可以用于开发Web游戏，因为游戏通常需要高性能的计算能力和快速的响应速度。WASM可以将游戏逻辑和渲染代码编译成高效的机器代码，从而提高游戏的性能。</p></li><li><p><strong>桌面应用</strong>：WASM可以用于开发桌面应用，因为桌面应用通常需要高性能的计算能力和丰富的用户界面。WASM可以将桌面应用的代码编译成高效的机器代码，从而提高应用的性能。</p></li><li><p><strong>服务器端应用</strong>：WASM可以用于开发服务器端应用，因为服务器端应用通常需要处理大量的数据和计算任务。WASM可以将服务器端应用的代码编译成高效的机器代码，从而提高应用的性能。</p></li><li><p><strong>插件和扩展</strong>：WASM可以用于开发浏览器插件和扩展，因为插件和扩展通常需要高性能的计算能力和丰富的用户界面。WASM可以将插件和扩展的代码编译成高效的机器代码，从而提高插件和扩展的性能。</p></li></ol><p>总之，WASM是一种强大的工具，可以用于开发高性能、安全且跨平台的Web应用。随着WASM的不断发展和优化，它将在更多的场景中得到应用。</p><h2 id="Rust编写WASM模块"><a href="#Rust编写WASM模块" class="headerlink" title="Rust编写WASM模块"></a>Rust编写WASM模块</h2><p>WASM生态中，Rust是一个比较活跃且稳定发展的WASM构建选项。Rust的开发环境推荐使用VSCode的<code>Rust-Analyzer</code>，有非常好的类型提示和方便的调试测试。</p><h3 id="工具与开发环境配置"><a href="#工具与开发环境配置" class="headerlink" title="工具与开发环境配置"></a>工具与开发环境配置</h3><p>WASM的编译依赖工具：<code>wasm-pack</code> 和 <code>wasm-opt</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo install wasm-pack<br>cargo install wasm-opt<br></code></pre></td></tr></table></figure><p>随后在<code>cargo,.toml</code> 中添加<code>wasm-bindgen</code>依赖：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[package]</span><br><span class="hljs-attr">name</span> = <span class="hljs-string">&quot;wasm_rust&quot;</span><br><span class="hljs-attr">version</span> = <span class="hljs-string">&quot;0.1.0&quot;</span><br><span class="hljs-attr">edition</span> = <span class="hljs-string">&quot;2021&quot;</span><br><br><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">wasm-bindgen</span> = <span class="hljs-string">&quot;0.2&quot;</span><br><br><span class="hljs-section">[lib]</span><br><span class="hljs-attr">crate-type</span> = [<span class="hljs-string">&quot;cdylib&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="代码调试与编译"><a href="#代码调试与编译" class="headerlink" title="代码调试与编译"></a>代码调试与编译</h3><p>尽管提供了一个用于测试的整数加法的函数，我们可以编写一个递归的斐波拉契的数列函数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> wasm_bindgen::prelude::*; <br><br><span class="hljs-meta">#[wasm_bindgen]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(left: <span class="hljs-type">f32</span>, right: <span class="hljs-type">f32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f32</span> &#123;<br>    <span class="hljs-keyword">return</span> left + right;<br>&#125;<br><span class="hljs-meta">#[wasm_bindgen]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fib</span>(n: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br>        -<span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) || (n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_ invoke__">fib</span>(n - <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>需要注意的是，我们要对需要编译成wasm的函数前面加上<code>#[wasm_bindgen]</code>的宏才可以在前端中被调用。</p><p>随后通过<code>wasm-pack</code>将Rust编译成WebAssembly：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wasm-pack build --target web<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/02/09/dBEP5SpYFostwi9.png" alt="{93C2DAED-BAD6-4E64-944C-F996359B96CD}"></p><p>成功的样子应该是这样的，你可以在目录找到<code>pkg</code>文件夹中的<code>.wasm</code>文件。</p><h2 id="在前端项目使用WASM"><a href="#在前端项目使用WASM" class="headerlink" title="在前端项目使用WASM"></a>在前端项目使用WASM</h2><p>直接在当前目录下新建一个Vue项目使用WASM，先按照下方的指令创建Vue项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm create vue@latest<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2025/02/09/3mNHxr4uqiTLlAC.png" alt="{65877B01-D330-4CEC-8F47-6305BCB547AD}"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> vue-wasm<br>npm install<br></code></pre></td></tr></table></figure><p>随后我们开始进行相关的配置。</p><h3 id="前端项目的WASM配置"><a href="#前端项目的WASM配置" class="headerlink" title="前端项目的WASM配置"></a>前端项目的WASM配置</h3><p>配置<code>vite.config.js</code>或<code>vite.config.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">assetsInclude</span>: [<span class="hljs-string">&quot;**/*.wasm&quot;</span>], <span class="hljs-comment">// &lt;= 添加这个以支持WASM</span><br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-title function_">vue</span>(),<br>    <span class="hljs-title function_">vueDevTools</span>(),<br>  ],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: <span class="hljs-title function_">fileURLToPath</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(<span class="hljs-string">&#x27;./src&#x27;</span>, <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">url</span>))<br>    &#125;,<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样才能开启对<code>wasm</code>的文件加载支持。</p><h3 id="WASM加载器的使用"><a href="#WASM加载器的使用" class="headerlink" title="WASM加载器的使用"></a>WASM加载器的使用</h3><p>将编译好的文件夹复制到前端项目中，比如说新建一个<code>wasm</code>的文件夹，容纳其中的内容。随后新建一个js文件<code>wasmLoader.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> init, &#123; fib &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./wasm_rust&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">loadWasm</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-title function_">init</span>();<br>    <span class="hljs-keyword">return</span> &#123; fib &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个组件将会暴露出我们要使用的函数，我们会在后面使用它。</p><h3 id="组件使用WASM"><a href="#组件使用WASM" class="headerlink" title="组件使用WASM"></a>组件使用WASM</h3><p>给个简单的使用案例吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">// App.vue<br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;;<br>import &#123; loadWasm &#125; from &#x27;./wasm/wasmLoader&#x27;;<br>const result = ref(0);<br>const count = ref(0);<br><br>const calculate_fib = async() =&gt;&#123;<br>  const wasm = await loadWasm();<br>  count.value ++;<br>  result.value = wasm.fib(count.value)<br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  <br>  &lt;div&gt;<br>    &lt;h1&gt;WASM DEMO&lt;/h1&gt;<br>    &lt;h2&gt;Rust + Vue3 + WASM&lt;/h2&gt;<br>    &lt;button @click=&quot;calculate_fib&quot;&gt;斐波拉契数列第&#123;&#123; count &#125;&#125;项：&#123;&#123; result &#125;&#125;&lt;/button&gt;  <br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br></code></pre></td></tr></table></figure><p>然后修改一下样式就好：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css">// <span class="hljs-attribute">src</span>/assets/<span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.css</span>:<br>*&#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">color</span>: darkseagreen;<br>&#125;<br><br><span class="hljs-selector-id">#app</span>&#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100vh</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100vw</span>;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">29</span>, <span class="hljs-number">29</span>, <span class="hljs-number">29</span>);<br>&#125;<br><br><span class="hljs-selector-tag">div</span>&#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">flex-direction</span>: column; <br>&#125;<br><br><span class="hljs-selector-tag">h1</span>&#123;<br>  <span class="hljs-attribute">color</span>: aliceblue;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">3vw</span>;<br>&#125;<br><br><span class="hljs-selector-tag">button</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20vw</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">5vh</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">114</span>, <span class="hljs-number">194</span>, <span class="hljs-number">170</span>); <br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">cursor</span>: pointer;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">5%</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">4vw</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如图：</p><p><img src="https://s2.loli.net/2025/02/22/qd5zKLb8TQXxyPo.png" alt="{27DF79DE-19BB-4686-A2A3-349AB87CE2FD}"></p><p>点击按钮会自增1，用于求斐波拉契的数列的第n项。大功告成~</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WebAssembly</tag>
      
      <tag>Rust</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>制作一个类怒喵AFA的分体Alice键盘</title>
    <link href="/nrf52840-8615459c9377/"/>
    <url>/nrf52840-8615459c9377/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>怒喵的AFA是真的帅啊…</p><p><img src="https://cdn-www.angrymiao.com/am_afa/am_afa_swiper_02_03.jpg"></p><p>但是价格太贵了。我决定自己做一个。这是一个烂尾的项目，项目地址在这里：<a href="https://github.com/Dafeigy/NUl4ice">Dafeigy&#x2F;NUl4ice: Alice layout keyboard using zmk firmware.</a></p><h2 id="主控选择"><a href="#主控选择" class="headerlink" title="主控选择"></a>主控选择</h2><p>NRF52840兼容 <code>NiceNano! v2</code>，无名科技的<a href="https://www.nologo.tech/product/otherboard/NRF52840.html#%E4%BA%A7%E5%93%81%E5%8F%82%E6%95%B0">产品介绍页</a>中有关于Promicro nrf52840的介绍。引脚图如下：</p><p><img src="https://www.nologo.tech/assets/img/other/NRF52840/ProMicroNRF52840Foot.jpg" alt="ProMicroNRF52840"></p><p>从中可以看到，一共有 18 个GPIO口可以给我们使用，并且有8个是高速的。构建一个键盘重要的是看开发板的可用GPIO引脚个数，因为键盘需要的引脚数为<strong>最大列数 + 最大行数</strong>。 以最入门的分体键盘 <a href="https://github.com/foostan/crkbd">Corne36</a> 为例：</p><p><img src="https://s2.loli.net/2025/04/05/3fjoSJbap6eNGKv.png" alt="corne36 layout by keymap editor"></p><p>每一边的最大行数为4，最大列数为6，因此总共需要6+4&#x3D;10个GPIO进行开发，我们也可以在Corne的原理图中证实这一点:</p><p><img src="https://pic1.imgdb.cn/item/67f1eabe0ba3d5a1d7ee291c.png" alt="原理图"></p><p>注意到row一共有4个，col一共有6个，分别对应到了ProMicro的15-20以及7-10的GPIO口，一共十个。</p><h3 id="布局参考"><a href="#布局参考" class="headerlink" title="布局参考"></a>布局参考</h3><p>当然第一步要考虑布局啦。用Alice就是为了用的舒服嘛，键盘布局生成网站是 <a href="https://www.keyboard-layout-editor.com/#/">Keyboard Layout Editor</a> （KLE），当然我不会自己去从头弄一个Alice布局，一来我没时间做测量（其实是不会呃呃呃），二来我本身就是用Alice配列，所以直接参考一些别人现有的工作即可。</p><ul><li><p><a href="https://github.com/4nh3k/TrongDong40">4nh3k&#x2F;TrongDong40: An open-source 40% Alice-like keyboard</a> 的 40%配列Alice键盘</p><p><img src="https://s2.loli.net/2025/04/05/RaK3WpDw4Z2ul8X.png" alt="TrongDong40-Alice-layout"></p></li><li><p>来自<a href="https://gist.github.com/twelvehouse/2a733f2ac6324826e8862a4405cd2b82">Owlab Spring Style Alice Layout Keyboard</a> 分享的Owlab Spring的经典Alice 布局：</p><p><img src="https://s2.loli.net/2025/04/05/QTrRs2EiZFGCKHq.png" alt="Spring-alice-layout"></p></li></ul><p>主要参考这两个，其他的一些Alice布局我个人感觉不具备美感，或者是最底行的按键布局我使用起来很不习惯，所以不纳入考虑。善用搜索可以找到很多分享键盘布局KLE json文件的用户。</p><h2 id="ZMK固件编写"><a href="#ZMK固件编写" class="headerlink" title="ZMK固件编写"></a>ZMK固件编写</h2><p>对于RGB以及LED，分体式的键盘需要单独开启宏。对于像Corne这种底灯和背光灯共用一个针脚的，需要在<code>.overlay</code>文件中修改WS2812的<code>chain-length</code>长度，这样才可以共用所有的灯效。</p><h2 id="ZMK固件编写-1"><a href="#ZMK固件编写-1" class="headerlink" title="ZMK固件编写"></a>ZMK固件编写</h2><p>参考：<a href="https://zmk.dev/docs/development/hardware-integration/new-shield">New Keyboard Shield | ZMK Firmware</a>。主要步骤如下：</p><ul><li>创建一个新的包含新的Shield的 ZMK 模块。</li><li>创建一个新的Shield目录。</li><li>添加基础 Kconfig 文件。</li><li>添加Shield层叠加文件（<code>*.overlay</code>）定义：<ul><li>键盘扫描驱动程序以检测按键&#x2F;释放。</li><li>矩阵转换以将键盘扫描行&#x2F;列值映射到键映射中的键位置。</li><li>物理布局定义以选择矩阵转换和键盘扫描实例。</li></ul></li><li>添加一个默认的键盘映射，用户可以根据需要在自己的配置中覆盖。</li><li>添加一个 <code>&lt;my_shield&gt;.zmk.yml</code> 元数据文件来记录shield的高级细节以及它支持的功能。</li></ul><p>在正式开始前，可以先看看<a href="https://docs.zephyrproject.org/3.5.0/hardware/porting/shields.html#shields"> Zephyr Shields </a>中关于Shield的定义。Shield可以附加到一个板上以扩展其功能和服务，便于模块化的原型设计。在 Zephyr 中，Shield功能提供了 Zephyr 格式的Shield描述，以便与应用程序更容易地兼容。Shield的配置文件位于board下的文件夹中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">boards/shields/&lt;shield&gt;<br>├── &lt;shield&gt;.overlay<br>├── Kconfig.shield<br>└── Kconfig.defconfig<br></code></pre></td></tr></table></figure><p>这些文件提供了shield配置如下：</p><ul><li><strong><shield>.overlay</strong>:此文件提供了一种Shield描述，以设备树格式呈现，并在编译前与板载设备树合并。</li><li><strong>Kconfig.shield</strong>：此文件定义了Shield的Kconfig 符号，用于默认Shield配置。为了方便应用程序使用，此处的默认Shield配置应与编写设备树中的配置保持一致。</li><li>Kconfig.defconfig：此文件定义了默认Shield配置。它旨在与编写设备树中的配置保持一致。因此，Shield配置应考虑到功能激活是应用程序的责任。</li></ul><p>分体式键盘的构建需要在<code>app/boards/shields</code>中新建一个文件夹<code>NULice</code>用来存放相关文件。这个文件夹的文件结构如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">NULice<br>├── Kconfig.defconfig<br>├── Kconfig.shield<br>├── boards<br>│   ├── nice_nano.overlay<br>│   └── nice_nano_v2.overlay<br>├── NULice.conf<br>├── NULice.dtsi<br>├── NULice.keymap<br>├── NULice.zmk.yml<br>├── NULice_left.conf<br>├── NULice_left.overlay<br>├── NULice_right.conf<br>└── NULice_right.overlay<br><br>2 directories, 12 files<br></code></pre></td></tr></table></figure><p>每个文件的作用将会被说明。</p><h3 id="Kconfig-shield"><a href="#Kconfig-shield" class="headerlink" title="Kconfig.shield"></a>Kconfig.shield</h3><p><code>Kconfig.shield</code> 文件定义了用于构建键盘的 shield 名称。分体键盘定义了多个 shield 名称，每个部分一个。例如，如果键盘由名为 <code>my_keyboard_left</code> 和 <code>my_keyboard_right</code> 的两部分组成，它将如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"># No whitespace after the comma or in your part name!<br>config SHIELD_MY_KEYBOARD_LEFT<br>    def_bool $(shields_list_contains,my_keyboard_left)<br><br># No whitespace after the comma or in your part name!<br>config SHIELD_MY_KEYBOARD_RIGHT<br>    def_bool $(shields_list_contains,my_keyboard_right)<br></code></pre></td></tr></table></figure><p>注意在末尾没有分号。这样将会在使用 <code>SHIELD_MY_KEYBOARD_LEFT</code> 作为Shield名称时将 <code>y</code> 标志设置为 <code>my_keyboard_left</code> 。同样，当使用 <code>my_keyboard_right</code> 作为Shield名称时， <code>SHIELD_MY_KEYBOARD_RIGHT</code> 标志将被设置为 <code>y</code> 。 <code>SHIELD_MY_KEYBOARD_LEFT</code> 和 <code>SHIELD_MY_KEYBOARD_RIGHT</code> 标志将在 <code>Kconfig.defconfig</code> 中用于设置其他Shield的属性，因此请确保它们匹配。</p><h3 id="Kconfig-defconfig"><a href="#Kconfig-defconfig" class="headerlink" title="Kconfig.defconfig"></a>Kconfig.defconfig</h3><p><code>Kconfig.defconfig</code> 文件用于设置此Shield使用时的新默认配置设置。通常在此处设置一个新的默认值是 <code>ZMK_KEYBOARD_NAME</code> 值，它控制设备通过 USB 和 BLE 的显示名称。更新后的新的默认值应该始终包含在 <code>Kconfig.shield</code> 文件中定义的Shield配置名称的条件中。对于分体键盘，中央一侧（通常是左侧）通过此文件中的配置来指定。对于该侧，分配键盘名称并设置中央配置。外围侧不分配名称。最后，需要为两侧设置分体配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Kconfig.defconfig</span><br><span class="hljs-keyword">if</span> SHIELD_MY_KEYBOARD_LEFT<br><br># Name must be less than <span class="hljs-number">16</span> characters <span class="hljs-type">long</span>!<br>config ZMK_KEYBOARD_NAME<br>    <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;My Keyboard&quot;</span><br><br>config ZMK_SPLIT_ROLE_CENTRAL<br>    <span class="hljs-keyword">default</span> y<br><br>endif<br><br><span class="hljs-keyword">if</span> SHIELD_MY_KEYBOARD_LEFT || SHIELD_MY_KEYBOARD_RIGHT<br><br>config ZMK_SPLIT<br>    <span class="hljs-keyword">default</span> y<br><br>endif<br></code></pre></td></tr></table></figure><h3 id="Shield-Overlays"><a href="#Shield-Overlays" class="headerlink" title="Shield Overlays"></a>Shield Overlays</h3><p>Shield overlay 文件包含一个设备树描述，该描述在固件构建过程中与主板设备树描述合并。此文件中需要定义三件事：</p><ul><li>键盘扫描（kscan）驱动程序，决定了哪些 GPIO 引脚用于检测按键事件</li><li>矩阵转换，充当“桥梁”，连接 kscan 和键帽映射</li><li>物理布局，聚合上述内容，并且（可选地）定义物理键位，以便键盘可以与 ZMK Studio 一起使用。</li></ul><p>分体键盘将为每个分体部分定义一个覆盖文件。例如，如果键盘被分成左半部分和右半部分，这些文件可以命名为：</p><ul><li><code>my_keyboard_left.overlay</code></li><li><code>my_keyboard_right.overlay</code></li></ul><p>这里 <code>my_keyboard_left</code> 和 <code>my_keyboard_right</code> 是 Kconfig.shield 文件中定义的 shield 名称。分体键盘 often 共享一些他们的 devicetree 描述。标准的方法是有一个核心 <code>my_keyboard.dtsi</code> (device tree include) 文件，该文件被包含到每个Shield</p><p>Overlay中。</p><h3 id="Kscan"><a href="#Kscan" class="headerlink" title="Kscan"></a>Kscan</h3><p>kscan 节点定义了用于扫描按键按下和释放事件的控制器 GPIO 引脚。对于NiceNano或ProMicro而言，其引脚定义如下:</p><p><img src="https://zmk.dev/assets/images/pinout-4ed4b6eb1e452a7be44c3a0143cd5605.png" alt="Promicro"></p><p>ZMK使用的是Arduino的引脚命名规则。ZMK 使用蓝色编码的“Arduino”引脚名称来生成设备树节点引用。例如，在图中标记为 <code>0</code> 的引脚，在设备树文件中使用 <code>&amp;pro_micro 0</code> 来引用。要使用上述互连之外的 GPIO 引脚，可以使用每个控制器类型特有的 GPIO 标签。例如，在基于 nRF52840 的板子上，编号为 <code>PX.Y</code> 的引脚可以通过 <code>&amp;gpioX Y</code> 标签来引用。例如，nice!nano 板子中间的 <code>&amp;gpio1 7</code> 引脚就是通过 <code>P1.07</code> 标签暴露出来的。你可以在<a href="https://zmk.dev/docs/config/kscan">这里</a>查看Kscan的详细细节。</p><p>对于分体键盘，您应该在 <code>my_keyboard.dtsi</code> 中定义您的 kscan。如果您的 <code>row-gpios</code> 或 <code>col-gpios</code> （两者都）在两部分之间是相同的，那么它们也应该在 <code>my_keyboard.dtsi</code> 中定义。例如，对于一个 <code>col2row</code> 两部分的分体键盘（18 个按键分为两半，每半都是 3x3 的宏键盘），如果用于“行”的 GPIO 引脚在两半中都相同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_keyboard.dtsi</span><br>/ &#123;<br>    kscan0: kscan0 &#123;<br>        compatible = <span class="hljs-string">&quot;zmk,kscan-gpio-matrix&quot;</span>;<br>        diode-direction = <span class="hljs-string">&quot;col2row&quot;</span>;<br>        wakeup-source;<br><br>        row-gpios<br>            = &lt;&amp;pro_micro <span class="hljs-number">6</span> (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)&gt;<br>            , &lt;&amp;pro_micro <span class="hljs-number">7</span> (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)&gt;<br>            , &lt;&amp;pro_micro <span class="hljs-number">8</span> (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)&gt;<br>            ;<br><br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>缺少的 <code>col-gpios</code> 将在你的 <code>my_keyboard_left.overlay</code> 和 <code>my_keyboard_right.overlay</code> 文件中定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_keyboard_left.overlay</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_keyboard.dtsi&quot;</span> <span class="hljs-comment">// The shared dtsi file is included in the overlay</span></span><br><br><span class="hljs-comment">// Label of the kscan node in the dtsi</span><br>&amp;kscan0 &#123;<br>    col-gpios<br>        = &lt;&amp;pro_micro <span class="hljs-number">19</span> GPIO_ACTIVE_HIGH&gt;<br>        , &lt;&amp;pro_micro <span class="hljs-number">18</span> GPIO_ACTIVE_HIGH&gt;<br>        , &lt;&amp;pro_micro <span class="hljs-number">15</span> GPIO_ACTIVE_HIGH&gt;<br>        ;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_keyboard_right.overlay</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;my_keyboard.dtsi&quot;</span> <span class="hljs-comment">// The shared dtsi file is included in the overlay</span></span><br><br><span class="hljs-comment">// Label of the kscan node in the dtsi</span><br>&amp;kscan0 &#123;<br>    col-gpios<br>        = &lt;&amp;pro_micro <span class="hljs-number">10</span> GPIO_ACTIVE_HIGH&gt;<br>        , &lt;&amp;pro_micro <span class="hljs-number">11</span> GPIO_ACTIVE_HIGH&gt;<br>        , &lt;&amp;pro_micro <span class="hljs-number">13</span> GPIO_ACTIVE_HIGH&gt;<br>        ;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h3><p>矩阵变换用于将行&#x2F;列事件转换为“键位”事件。当按键被按下时，会生成一个 kscan 事件，该事件带有 <code>row</code> 和 <code>column</code> 值，分别对应触发事件的 <code>row-gpios</code> 和 <code>col-gpios</code> 引脚的零基索引。然后，“键位”触发的是矩阵变换中 <code>RC(row, column)</code> 的位置，其中 <code>row</code> 和 <code>column</code> 是上述提到的索引。该键位将与键映射中的行为绑定相关联。</p><p>分体键盘应在共享 <code>my_keyboard.dtsi</code> 中定义其矩阵变换。在文件顶部添加 <code>#include &lt;dt-bindings/zmk/matrix_transform.h&gt;</code> 。以下是对上一个示例（18 键双宏键盘）的矩阵转换示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_keyboard.dtsi</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/zmk/matrix_transform.h&gt;</span> <span class="hljs-comment">// Put this with the other includes at the top of your dtsi</span></span><br><br>/ &#123;<br>    default_transform: keymap_transform0 &#123;<br>        compatible = <span class="hljs-string">&quot;zmk,matrix-transform&quot;</span>;<br>        columns = &lt;<span class="hljs-number">6</span>&gt;;<br>        rows = &lt;<span class="hljs-number">3</span>&gt;;<br>        <span class="hljs-built_in">map</span> = &lt;<br>        <span class="hljs-comment">//  LKey 1 |LKey 2 |LKey 3      RKey 1 |RKey 2 |RKey 3</span><br>            RC(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) RC(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) RC(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)     RC(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>) RC(<span class="hljs-number">0</span>,<span class="hljs-number">4</span>) RC(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)<br>        <span class="hljs-comment">//  LKey 4 |LKey 5 |LKey 6      RKey 4 |RKey 5 |RKey 6</span><br>            RC(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) RC(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) RC(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)     RC(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>) RC(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>) RC(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)<br>        <span class="hljs-comment">//  LKey 7 |LKey 8 |LKey 9      RKey 7 |RKey 8 |RKey 9</span><br>            RC(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>) RC(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>) RC(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)     RC(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>) RC(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>) RC(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)<br>        &gt;;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上述变换有 6 列和 3 行，而键盘的每一半只有 3 列和 3 行。为了使外设的矩阵变换能够与 kscan 矩阵连接，在外设的矩阵变换中应用了一个偏移量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_keyboard_right.overlay</span><br>&amp;default_transform &#123; <span class="hljs-comment">// Offset of 3 because the left side has 3 columns</span><br>    col-offset = &lt;<span class="hljs-number">3</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个偏移量意味着当键盘右半部分由其 <code>row-gpios</code> 和 <code>col-gpios</code> 数组中索引 <code>0,0</code> 的 GPIO 引脚触发键事件时，它会被解释为 <code>RC(0,3)</code> 事件而不是 <code>RC(0,0)</code> 事件。额外的外设需要其列偏移量等于中央部分的列数与之前所有外设列数之和。你还可以使用 <code>row-offset</code> 应用行偏移量。</p><p>矩阵变换也被用来“纠正”针脚排序，使其更接近键的实际排列顺序。针脚排序异常的原因包括：</p><ul><li>为了减少使用的针脚，使用了一个“高效”的 GPIO 矩阵行&#x2F;列数，这并不匹配实际键开关行&#x2F;列的实际布局。</li><li>对于非矩形键盘、拇指簇、非 <code>1u</code> 位置等.</li></ul><p>ZMK 定义了一些内置键盘以了解更复杂的矩阵转换，可以在<a href="https://github.com/zmkfirmware/zmk/tree/main/app/boards/shields">这里</a>查看下。</p><h3 id="默认键盘布局"><a href="#默认键盘布局" class="headerlink" title="默认键盘布局"></a>默认键盘布局</h3><p>每个键盘应该提供一个默认键位布局，当构建固件时使用，用户可以通过自定义配置文件覆盖和自定义。对于“Shield键盘”，这应该放在 <code>boards/shields/my_keyboard/my_keyboard.keymap</code> 文件中。这是一个仅有一层的 3x3 宏键盘的简单键位映射示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_keyboard.keymap</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;behaviors.dtsi&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dt-bindings/zmk/keys.h&gt;</span></span><br><br>/ &#123;<br>    keymap &#123;<br>        compatible = <span class="hljs-string">&quot;zmk,keymap&quot;</span>;<br><br>        default_layer &#123; <span class="hljs-comment">// Layer 0</span><br>            <span class="hljs-comment">// -------------------------------------</span><br>            <span class="hljs-comment">// |     Z     |     M     |     K     |</span><br>            <span class="hljs-comment">// |     A     |     B     |     C     |</span><br>            <span class="hljs-comment">// |     D     |     E     |     F     |</span><br>            bindings = &lt;<br>                &amp;kp Z    &amp;kp M    &amp;kp K<br>                &amp;kp A    &amp;kp B    &amp;kp C<br>                &amp;kp D    &amp;kp E    &amp;kp F<br>            &gt;;<br>        &#125;;<br>    &#125;;<br> &#125;;<br></code></pre></td></tr></table></figure><p>键映射应与矩阵转换中键的顺序完全匹配，从左到右，从上到下（它们都是用换行字符重新排列的一维数组，以便更易于阅读）。有关在 ZMK 中定义键映射的信息，请参见键映射。如果您希望使用 ZMK Studio 来配置您的键盘，请确保在键映射中为 ZMK Studio 的解锁行为分配一个键。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>连接问题：</p><h3 id="蓝牙连接列表中无法连接"><a href="#蓝牙连接列表中无法连接" class="headerlink" title="蓝牙连接列表中无法连接"></a>蓝牙连接列表中无法连接</h3><p>一般的说法是</p><h3 id="蓝牙识别的设备名称没有变更"><a href="#蓝牙识别的设备名称没有变更" class="headerlink" title="蓝牙识别的设备名称没有变更"></a>蓝牙识别的设备名称没有变更</h3><p>改名：改名一般情况下需要重新刷一下重置固件。具体做法是在编译正式的固件前先编译一个reset固件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">west build -d ../build -p -b nice_nano_v2 -- -DSHIELD=settings_reset<br></code></pre></td></tr></table></figure><p>即<code>-DSHIELD=settings_reset</code>这一块。烧录Reset固件后再进行正式的新键盘固件烧录，这样就能在蓝牙中显示正确的名称了。</p><p>Reference：<a href="https://zmk.dev/docs/troubleshooting/connection-issues#:~:text=These%20issues%20can%20be%20resolved%20by%20flashing%20a,Bluetooth%20profiles%2C%20output%20selection%2C%20RGB%20underglow%20color%2C%20etc.">ZMK文档</a>和<a href="https://www.answeroverflow.com/m/1307444107098062938">AnswerOverFlow</a>。</p><h3 id="左右分体无法识别"><a href="#左右分体无法识别" class="headerlink" title="左右分体无法识别"></a>左右分体无法识别</h3><h3 id="右手固件"><a href="#右手固件" class="headerlink" title="右手固件"></a>右手固件</h3><p>ZMK的逻辑是：右手分体的键盘信息通过BLE传输给主手（左手），由主手通过BLE再发送到连接的设备中，因此单独检验左手不能用。</p>]]></content>
    
    
    <categories>
      
      <category>键盘制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zmk</tag>
      
      <tag>摸鱼</tag>
      
      <tag>键盘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cygnus构建记录</title>
    <link href="/Cygnus%E6%9E%84%E5%BB%BA-a30739ae4799/"/>
    <url>/Cygnus%E6%9E%84%E5%BB%BA-a30739ae4799/</url>
    
    <content type="html"><![CDATA[<h2 id="固件开发环境设置"><a href="#固件开发环境设置" class="headerlink" title="固件开发环境设置"></a>固件开发环境设置</h2><p>固件（Firmware）就是写入 ROM （只读存储器）中的程序，固件担任着一个系统最基础最底层工作，直接控制硬件。它位于硬件和应用软件之间。它是写入设备存储器（通常是闪存或 ROM）中的程序，负责控制硬件的基本功能和运行逻辑。</p><p>我这里使用的固件是ZMK，开发有什么问题，可以直接翻<a href="https://zmk.dev/docs">官方文档</a>。使用ZMK主要是看重它支持无线能力，这对我构建一个无线分体键盘来说还挺关键的，可选的选项其实也不多，所以就使用ZMK咯。</p><h3 id="ZMK环境配置"><a href="#ZMK环境配置" class="headerlink" title="ZMK环境配置"></a>ZMK环境配置</h3><p>本地开发环境请参考<a href="https://zmk.dev/docs/development/local-toolchain/setup/native">官方原生开发环境构建指南</a>，也有容器型的开发环境，但我觉得没必要。首先先把仓库克隆下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/zmkfirmware/zmk.git<br></code></pre></td></tr></table></figure><p>然后进入仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> zmk<br></code></pre></td></tr></table></figure><h3 id="获取-Zephyr-并安装-Python-依赖项"><a href="#获取-Zephyr-并安装-Python-依赖项" class="headerlink" title="获取 Zephyr 并安装 Python 依赖项"></a>获取 Zephyr 并安装 Python 依赖项</h3><ol><li><p>使用 <code>apt</code> 安装 Python <code>venv</code> 包：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install python3-venv<br></code></pre></td></tr></table></figure></li><li><p>创建一个新的虚拟环境并激活它：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -m venv .venv<br><span class="hljs-built_in">source</span> .venv/bin/activate<br></code></pre></td></tr></table></figure><p> 一旦激活，你的 shell 将会有一个前缀为 <code>(.venv)</code> 的标识。随时可以通过运行 <code>deactivate</code> 来关闭虚拟环境。</p></li><li><p>安装west：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install west<br></code></pre></td></tr></table></figure></li><li><p>初始化应用并更新包含<code>Zephyr</code>的模块：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">west init -l app/<br>west update<br></code></pre></td></tr></table></figure><p> 这个部分会下载若干个Github仓库，需要科学上网。</p></li><li><p>导出一个 Zephyr CMake 包。这使得 CMake 能够自动加载构建 Zephyr 应用程序所需的样板代码:</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">west zephyr-export<br></code></pre></td></tr></table></figure></li><li><p>安装 Zephyr 所列出的额外依赖项：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install -r zephyr/scripts/requirements-base.txt<br></code></pre></td></tr></table></figure></li></ol><h3 id="安装-Zephyr-SDK"><a href="#安装-Zephyr-SDK" class="headerlink" title="安装 Zephyr SDK"></a>安装 Zephyr SDK</h3><p>参考<a href="https://docs.zephyrproject.org/3.5.0/develop/getting_started/index.html#install-zephyr-sdk">Zephyr SDK 安装指南</a>。</p><ol><li><p>下载并验证 Zephyr SDK 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br>wget https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.3/zephyr-sdk-0.16.3_linux-x86_64.tar.xz<br>wget -O - https://github.com/zephyrproject-rtos/sdk-ng/releases/download/v0.16.3/sha256.<span class="hljs-built_in">sum</span> | shasum --check --ignore-missing<br></code></pre></td></tr></table></figure><p>如果主机架构是 64 位 ARM（例如，Raspberry Pi，但我感觉应该个人用户应该没有吧…），需要将 <code>x86_64</code> 替换为 <code>aarch64</code> 以下载 64 位 ARM Linux SDK。</p></li><li><p>提取 Zephyr SDK 包存档:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xvf zephyr-sdk-0.16.3_linux-x86_64.tar.xz<br></code></pre></td></tr></table></figure></li><li><p>运行 Zephyr SDK 捆绑包设置脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> zephyr-sdk-0.16.3<br>./setup.sh<br></code></pre></td></tr></table></figure><p>这个脚本只需要执行一次即可。如果后续移动了Zeohyr SDK的位置，那么需要重新运行setup脚本。</p></li><li><p>安装 udev 规则，以便您可以以普通用户身份刷写大多数 Zephyr 板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">cp</span> ~/zephyr-sdk-0.16.3/sysroots/x86_64-pokysdk-linux/usr/share/openocd/contrib/60-openocd.rules /etc/udev/rules.d<br><span class="hljs-built_in">sudo</span> udevadm control --reload<br></code></pre></td></tr></table></figure></li></ol><h2 id="固件编写"><a href="#固件编写" class="headerlink" title="固件编写"></a>固件编写</h2><p>Cygnus是可以使用Corne的固件的。但是如果要进行个性化的相关设置，你可以自定义固件。首先复制一份<code>app/boards/shields/corne</code>的文件夹，然后把文件夹和corne相关的，都改成<code>cygnus</code>。</p><h3 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h3><p>文件夹中的这几个文件需要额外修改：</p><ul><li><p><code>cygnus.zmk.yml</code>：修改<code>id</code>，<code>name</code>即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">file_format:</span> <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-attr">id:</span> <span class="hljs-string">cygnus</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">Cygnus</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">shield</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://github.com/foostan/crkbd/</span><br><span class="hljs-attr">requires:</span> [<span class="hljs-string">pro_micro</span>]<br><span class="hljs-attr">exposes:</span> [<span class="hljs-string">i2c_oled</span>]<br><span class="hljs-attr">features:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">keys</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">display</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">underglow</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">studio</span><br><span class="hljs-attr">siblings:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cygnus_left</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">cygnus_right</span><br></code></pre></td></tr></table></figure></li><li><p><code>Kconfig.shield</code>中的内容也需要修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">config SHIELD_CYGNUS_LEFT<br>    def_bool $(shields_list_contains,cygnus_left)<br><br>config SHIELD_CYGNUS_RIGHT<br>    def_bool $(shields_list_contains,cygnus_right)<br><br></code></pre></td></tr></table></figure></li><li><p>还有最重要的<code>cygnus.keymap</code>的修改，不过我们这里先不过多展开，会在后面的使用体验中进行介绍与修改。</p></li></ul><h3 id="固件编译与下载"><a href="#固件编译与下载" class="headerlink" title="固件编译与下载"></a>固件编译与下载</h3><p>主要参考资料在这：<a href="https://zmk.dev/docs/development/local-toolchain/build-flash">Building and Flashing | ZMK Firmware</a>。我们需要进入到<code>zmk/app</code>目录下进行操作。Cygnus由于是使用两块板子的附加形式，因此编译参考选择参考<code>Addon MCU</code>部分。我们使用的配置如下：</p><ul><li>MCU板子: nice_nano_v2</li><li>键盘PCB: cygnus_left &amp; cygnus_left</li></ul><p>编译左手固件的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">west build -b nice_nano_v2 -- -DSHIELD=cygnus_left<br></code></pre></td></tr></table></figure><p>当在之前构建过板子和&#x2F;或屏蔽后构建新的板子和&#x2F;或屏蔽时，可能需要启用纯净构建选项。此选项会在重新生成文件之前删除构建目录中的所有现有文件，并可以通过在命令中添加 –pristine 或 -p 来启用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">west build -p -b nice_nano_v2 -- -DSHIELD=cygnus_left<br></code></pre></td></tr></table></figure><p>默认情况下， <code>build</code> 命令会输出一个名为 <code>zmk.uf2</code> 的 .uf2 文件，因此连续构建左右两侧会覆盖左侧的固件。此外，还需要对每一侧进行 pristine 构建以确保使用正确的文件。为了避免每次都需要 pristine 构建并且分开左右两侧的构建文件，我们建议为每一半设置单独的构建目录。使用 <code>-d</code> 参数并在构建右侧时将其放入 <code>build/right</code> 中完成此操作。先编译右手：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">west build -d build/right -b nice_nano_v2 -- -DSHIELD=cygnus_right<br></code></pre></td></tr></table></figure><p>然后编译左手固件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">west build -d build/left -b nice_nano_v2 -- -DSHIELD=cygnus_left<br></code></pre></td></tr></table></figure><p>这会在 <code>build</code> 目录下生成 <code>left</code> 和 <code>right</code> 子文件夹，并生成两个单独的 <code>.uf2</code> 文件。后续可以用一个脚本把编译成功的固件重命名+打包压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start processing Firmware build.&quot;</span><br><span class="hljs-built_in">mkdir</span> -p zmk-firmware<br><span class="hljs-built_in">cd</span> ./app; <br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start processing left-hand Firmware.&quot;</span>;<br>west build -d build/left -b nice_nano_v2 -- -DSHIELD=cygnus_left; <br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start processing right-hand Firmware.&quot;</span>;<br>west build -d build/right -b nice_nano_v2 -- -DSHIELD=cygnus_right;<br><br><span class="hljs-built_in">cd</span> ../;<br><span class="hljs-built_in">mv</span> ./app/build/left/zephyr/zmk.uf2 ./zmk-firmware/left.uf2;<br><span class="hljs-built_in">mv</span> ./app/build/right/zephyr/zmk.uf2 ./zmk-firmware/right.uf2;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Build tasks finished. See ./zmk-firmware for details.&quot;</span><br></code></pre></td></tr></table></figure><p>这样就可以在<code>zmk</code>目录下运行指令，并在<code>zmk-firmware</code>文件夹下找到对应的左右固件的二进制文件了。</p><p>下载到NICENANO也很简单，短接RST和GND两次，然后就会在电脑上显示一个外部设备了。把刚刚的<code>.uf2</code>文件拖进去，等待文件传输完成，如果出现了如下异常：</p><p><img src="https://s2.loli.net/2025/02/15/4o9KD1J7qrgLv8h.png" alt="{EFBDC695-E1E2-43D1-8695-D6B04E3E827C}"></p><p>不用担心，直接跳过就好，这个时候外部设备应该也关闭了和主机的传输。</p><h2 id="3x5键位的设置"><a href="#3x5键位的设置" class="headerlink" title="3x5键位的设置"></a>3x5键位的设置</h2><p>参考<a href="https://www.zfrontier.com/app/flow/9RgzRVlAzJlN">这篇文章</a>进行设置。具体的一些行为编写如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">td_mt_l: tap_dance_mod_tap &#123;<br>    compatible = <span class="hljs-string">&quot;zmk,behavior-tap-dance&quot;</span>;<br>    <span class="hljs-comment">#binding-cells = &lt;0&gt;;</span><br>    tapping-term-ms = &lt;200&gt;;<br>    bindings = &lt;&amp;mt LCTRL SPACE&gt;, &lt;&amp;kp ESC&gt;;<br>    &#125;<br><br><span class="hljs-built_in">ls</span>: layer_switch &#123;<br>    compatible = <span class="hljs-string">&quot;zmk,behavior-hold-tap&quot;</span>;<br>    <span class="hljs-comment">#binding-cells = &lt;2&gt;;</span><br>    flavor = <span class="hljs-string">&quot;tap-preferred&quot;</span>;<br>    tapping-term-ms = &lt;200&gt;;<br>    quick-tap-ms = &lt;200&gt;;<br>    require-prior-idle-ms = &lt;125&gt;;<br>    bindings = &lt;&amp;mo&gt;, &lt;&amp;kp&gt;;<br>    &#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>键盘制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zmk</tag>
      
      <tag>摸鱼</tag>
      
      <tag>键盘</tag>
      
      <tag>无线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Corne构建记录</title>
    <link href="/cornemake-4a70eb1604f8/"/>
    <url>/cornemake-4a70eb1604f8/</url>
    
    <content type="html"><![CDATA[<h2 id="PCB下单"><a href="#PCB下单" class="headerlink" title="PCB下单"></a>PCB下单</h2><p>我使用的PCB是由从<a href="https://github.com/beekeeb/crkbd-glp.git">这里</a>得到的。作者修改了部分的灯位布局，最重要的是把按键从choc矮轴更换成了佳达隆矮轴（价格更便宜一点，且用的是十字键帽），让国人用户也能方便地体验到矮轴。PCB我是使用KiCAD将左手板和右手板拆分，然后导出钻孔文件和Gerber制板文件一同压缩成一个压缩包，然后将这个压缩包发给PCB制作的厂子进行印刷制作。</p><p>国内的PCB制作除了势头强劲的嘉立创，还有一些其他的企业，比如捷配。捷配提供的三张板免费打样可以很好地免费打印一些在嘉立创中超出免费打样尺寸的板子，这对制作键盘来讲非常有帮助。我这次打板也是在捷配进行打印的，感恩比心~</p><p>如果你也懒，不想自己下载KiCAD打开编辑PCB，那么你可以用我的PCB Gerber文件，我没有进行任何改动：</p><h2 id="焊接与外壳组装"><a href="#焊接与外壳组装" class="headerlink" title="焊接与外壳组装"></a>焊接与外壳组装</h2><p>你需要准备如下的材料进行Corne键盘的制作：</p><table><thead><tr><th>Name</th><th>Count</th><th>Remarks</th></tr></thead><tbody><tr><td>PCB</td><td>1 set</td><td></td></tr><tr><td>Top plate</td><td>2 sheets</td><td>1.2mm thick</td></tr><tr><td>Bottom plate</td><td>2 sheets</td><td></td></tr><tr><td>OLED cover</td><td>2 sheets</td><td></td></tr><tr><td>Pro Micro or equivalent</td><td>2</td><td></td></tr><tr><td>TRRS jack</td><td>2</td><td></td></tr><tr><td>Reset switch</td><td>2</td><td></td></tr><tr><td>Diodes</td><td>42</td><td>SMD Only (SOD-123 Package)</td></tr><tr><td>Gateron Low Profile Hotswap Sockets</td><td>42</td><td></td></tr><tr><td>Key switches</td><td>42</td><td>Only compatible with Gateron KS-33 &#x2F; KS-27</td></tr><tr><td>Keycaps</td><td>42 pieces</td><td>1u 40 pcs, 1.5u 2 pcs <a href="https://showcase.beekeeb.com/the-keycaps-of-gateron-low-profile-key-switches-and-kailh-choc-v1-key-switch/">Keycaps Comparison</a></td></tr><tr><td>Spacer M2 5mm</td><td>10 pieces</td><td>For Case assembly</td></tr><tr><td>Spacer M2 9mm</td><td>4 pieces</td><td>For OLED cover</td></tr><tr><td>Screw M2 4mm</td><td>28 screws</td><td></td></tr><tr><td>Rubber feet</td><td>8 pieces</td><td></td></tr><tr><td>TRRS (4 poles) cable</td><td>1</td><td></td></tr><tr><td>Micro USB or USB-C cable</td><td>1</td><td>Avoid charge-only cables</td></tr></tbody></table><h2 id="固件编写"><a href="#固件编写" class="headerlink" title="固件编写"></a>固件编写</h2><p>固件我使用了QMK进行编写。当然你也可以当蓝狗直接使用网上别人编译好的：</p><p>TODO</p><h2 id="第一把佳达隆矮轴分体键盘！"><a href="#第一把佳达隆矮轴分体键盘！" class="headerlink" title="第一把佳达隆矮轴分体键盘！"></a>第一把佳达隆矮轴分体键盘！</h2><p>恭喜33成为首位收到我制作的佳达隆矮轴Corne分体键盘（但作为一份生日礼物它实在是迟到了太久太久…）！Corne是一把分体设计、符合人体工学的小配列键盘，如果作为文字工作&#x2F;代码编写的生产力键盘来使用的话会非常麻烦，但如果从便携、简单的游戏键盘角度来看，它是个非常好的伴侣：</p><ul><li><p>直列设计，减少手指纵向移动的距离，缓和手部疲劳；</p></li><li><p>使用了QMK固件，并使用了Vial进行多种功能的实现；</p></li><li><p>分体式左主手设计，在游戏场景下可以把右半侧的键盘分离，实现更少的桌面空间占用；</p></li><li><p>高度的可自定义选项，不仅可以自行分配按键和布局，还能有多种炫彩光效；</p></li><li><p>具备后期升级为无线键盘的潜力…!实现真正的无线（连中间的连接线都不需要了）</p></li></ul><p>下面我会简要的介绍一下Corne的使用~</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>首先对于使用一把分体式的有线键盘，必须要说明的就是：</p><p><strong>不要在连接电脑时直接插拔两块键盘之间的连接线！</strong></p><p><strong>不要在连接电脑时直接插拔两块键盘之间的连接线！</strong></p><p><strong>不要在连接电脑时直接插拔两块键盘之间的连接线！</strong></p><p>如果这样做的话，主控（就是显示屏下面的两块黑色板子）会直接烧坏的(っ╥╯﹏╰╥c)，更换一个要差不多40块钱呢！</p><p>使用前，需要将USB-Typc连接线接入导Corne左半边的主控板type-c接口，大概过1-2秒键盘就会亮起灯光，你就可以开始使用啦！</p><h2 id="键位设置"><a href="#键位设置" class="headerlink" title="键位设置"></a>键位设置</h2><p>可以使用<a href="https://vial.rocks/">Vial Web</a>对Corne键盘进行键位设置（可能需要科学上网）。我设置了这样的键位：</p><p><img src="https://pic1.imgdb.cn/item/686a7b7758cb8da5c89293c5.png" alt="1751808719311"></p><p>给你简单解释一下这里面的意思吧！</p><ul><li>白色是第一层（<strong>base</strong>），这里主要放的是字母区以及常用的功能按键，例如 esc，ctrl，backspace 等。</li><li>“(Ctrl)” 带小括号的是表示这个按键长按时是括号内的键值，例如“Tab (Ctrl)”表示的就是点击输出 Tab, 按住时是 Ctrl。这个功能叫做 “MT”，即 “Mod-Tap”。<br>“[SETTING]” 中括号表示切层，我只用按住切层，这样可以自动恢复到默认层，这样你每次按键都是固定的，不会由于忘记回到默认层而破坏输入。“Space ([NUM])”表示点击是“Space”，按住切换到“NUM”层，这个行为叫做“LT”，即“Layer-Tap”。</li><li>蓝色是第二层（<strong>NUM</strong>），这里是 F 区，数字区，以及编辑区和方向键。</li><li>绿色是第三层（<strong>SYMBOL</strong>），这里是符号区，第一行对应数字区的符号，右手 2，3 行上下对应，分别是直接输出的符号和原本需要按 shift 输出的符号。（这里的“|”和“\”根据我的习惯做了交换）。</li><li>红色是第四层（<strong>SETTINGS</strong>），这里用了配置蓝牙，调整灯光。<br>左手拇指按下切换到数字层，右手拇指按下切换到符号层，一起按则进入设置层。</li></ul><p>其中，层的信息是可以通过Corne键盘的左侧小屏幕观察得到的哦！在Corne左侧键盘的屏幕里，页面是这样的：</p><p><img src="https://pic1.imgdb.cn/item/686a7eb158cb8da5c8929824.png"></p><p>从左到右分别是第一层（Base）、第二层（NUM）、第三层（SYMBOL）以及第四层（Settings）。第四层是最少用到的层，所以只需要记住：左手控制数字，右手控制符号就好。</p><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>看一下最终成品吧！</p><p><img src="https://pic1.imgdb.cn/item/686a91af58cb8da5c892adc2.jpg"></p><p><img src="https://pic1.imgdb.cn/item/686a8c5258cb8da5c892a8f5.jpg"></p><p>这把键盘的制作其实遇到了很多很多的问题…首先是绘制PCB时没有佳达隆矮轴的轴座，直接拿罗技的一块剪线板子的尺寸量的，导致画的一张板封装对不上直接报废；修改后打板子结果重复打错了左手部分，又浪费了一个月的时间（没有开企业认证只有一月一次免费）；然后是对主控烧写固件时，图便宜买了个13块钱的主控，结果固件烧录不进去，以为是自己的软件编译出问题，排查到了凌晨两点半都没解决，最后通过交流群听群友建议买了无名科技的RP2040 Helios开发板（价格差不多是便宜的那家的两倍），终于烧录成功了…</p><p>这般键盘的制作可谓历经波折。但也对我的动手能力有一定的提升，还积累了一些宝贵的焊接经验（比如我已经开始使用加热焊台对WS2812以及SK6812进行焊接，省时方便还不容易焊坏零件），同时这把Corne的外壳也是我3D建模并使用拓竹A1打印得到的，成本约等于5块钱吧！最后我来报一下正式的耗材成本吧：</p><table><thead><tr><th>名称</th><th>数量</th><th>渠道</th><th>总价格</th></tr></thead><tbody><tr><td>PCB-右侧板</td><td>1</td><td>捷配每月免费打样</td><td>0￥</td></tr><tr><td>PCB-左侧板</td><td>1</td><td>捷配每月免费打样</td><td>0￥</td></tr><tr><td>佳达隆矮轴</td><td>36</td><td>淘宝随便一家店</td><td>14.4￥</td></tr><tr><td>RP2040 Helios主控</td><td>2</td><td>淘宝-无名科技</td><td>51.6￥</td></tr><tr><td>1N4148 SOD-123</td><td>36</td><td>淘宝随便一家店</td><td>2￥</td></tr><tr><td>SK6812-mini反贴</td><td>36</td><td>淘宝随便一家店</td><td>忘了 以前的存货</td></tr><tr><td>WS2812</td><td>12</td><td>淘宝随便一家店</td><td>忘了 以前的存货</td></tr><tr><td>佳达隆矮轴</td><td>36</td><td>淘宝-哈狐 ChosFox企业店</td><td>47.5￥</td></tr><tr><td>超低结构排母12pin</td><td>4</td><td>淘宝-上一电子科技</td><td>31.2￥</td></tr><tr><td>超低结构排针12pin</td><td>4</td><td>淘宝-上一电子科技</td><td>31.2￥</td></tr><tr><td>0.92寸显示屏</td><td>2</td><td>淘宝随便一家店</td><td>18￥</td></tr></tbody></table><p>我陷入了沉思…为什么电路板免费了也要那么高的成本啊！！！但其实可以抛弃掉一些没必要的低结构排母、排针以及显示屏、两种灯，这样可以进一步压缩成本，做一把超低成本的Corne。</p>]]></content>
    
    
    <categories>
      
      <category>键盘制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>zmk</tag>
      
      <tag>摸鱼</tag>
      
      <tag>键盘</tag>
      
      <tag>无线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【摸】制作一个Github星标搜索应用</title>
    <link href="/StarGazers%E5%88%B6%E4%BD%9C-de2d6ab6f7cd/"/>
    <url>/StarGazers%E5%88%B6%E4%BD%9C-de2d6ab6f7cd/</url>
    
    <content type="html"><![CDATA[<h2 id="制作起因"><a href="#制作起因" class="headerlink" title="制作起因"></a>制作起因</h2><p>关注了几个很活跃的中文开发者，比如@karminiski-牙医，@Easy，他们都是有多年开发经验的技术大佬。他们的Github中有很多星标过的内容，可以看成是“大佬的肯定”的项目，具有一定的探索、参考、使用的价值。然而我发现Github的星标仓库搜索功能比较鸡肋，经常搜索不出来我想要的东西。因此打算结合向量搜索构建一个星标仓库搜索的工具，起名就叫“观星者（StarGazer）”。这次的制作思路还是我的常用技术，Flask作为后端，前端还是手写HTML&#x2F;CSS&#x2F;JS+jQuery，部署依然是白嫖Vercel，数据库也尝试一下和Vercel合作（？）的数据库UpStash。</p><p>这个项目的现阶段还是一个初期跑通的阶段，希望能在新年学一些新的技术，比如Vue3+tailwindcss重写前端，FastAPI或者使用Rust作为后端完善这个<a href="https://github.com/Dafeigy/StarsGazer">项目</a>。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>这个项目主要要进行两部分的内容：</p><ul><li>爬取指定用户的星标仓库并将其放入向量数据库，同时还要有一个更新数据库的功能；</li><li>根据用户的输入放入对向量数据库进行查询，并将返回的结果根据设定的相似度阈值进行筛选，渲染返回结果</li></ul><p>第一部分的内容主要是爬虫，第二部分的内容主要是交互，应该都不难，但要做好还是要花点心思。</p><h2 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h2><p>我想做成一个像素风格的。主色调用暗色+青色，再模仿一下perplexity的布局。整体布局是这样：</p><p><img src="https://s2.loli.net/2025/01/26/AEVxfpyNm1lj2Yb.png" alt="主要页面设计"></p><p>搜索结果的卡片：</p><p><img src="https://s2.loli.net/2025/01/26/1wLeaYI8FCOgbpn.png" alt="搜索卡片样式"></p><p>左边的debug窗口是我自己喜欢的一种风格，所以不喜欢的也可以删掉^_^</p><h2 id="开始Coding！"><a href="#开始Coding！" class="headerlink" title="开始Coding！"></a>开始Coding！</h2><h3 id="开发环境设置"><a href="#开发环境设置" class="headerlink" title="开发环境设置"></a>开发环境设置</h3><p>Windows下开发，Git bash作为终端，所有和密钥相关或者相关部署设置都用环境变量，然后用<code>os.environ[&quot;XXXXXX&quot;]</code>获取对应值。</p><p>编程辅助选择Cline+DeepSeekV2.5-Coder，不赋予修改代码权限。我还是更喜欢自己手动review AI的代码，不能完全解放双手。</p><h3 id="爬取数据"><a href="#爬取数据" class="headerlink" title="爬取数据"></a>爬取数据</h3><p>一开始我想的是应该有什么API获取星标仓库数据的吧，但是真的没找到…Github这个文档本身就没有搜索功能！气死我了。然后我就开始硬爬吧，发现需要的headers就两部分内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;user-agent&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Edg/132.0.0.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;content-type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后定位到这个URL<code>https://github.com/&#123;GITHUB_USERNAME&#125;?tab=stars</code>，用requests+BeautifulSoup解析一下就可以获取很多信息，比如使用的语言，星标数量，Forks数量，最近更新日期，项目链接，仓库作者信息，仓库介绍等，所以写个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_single_page</span>(<span class="hljs-params">url</span>):<br>    headers = &#123;<br>        <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Edg/132.0.0.0&quot;</span>,<br>        <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span><br>        &#125;<br>    req = requests.get(url, headers=headers)<br>    soup = BeautifulSoup(req.text, <span class="hljs-string">&quot;lxml&quot;</span>)<br>    search_field = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_ = <span class="hljs-string">&quot;col-lg-12&quot;</span>)<br>    langsdiv = search_field.findAll(<span class="hljs-string">&quot;div&quot;</span>, class_=<span class="hljs-string">&#x27;f6 color-fg-muted mt-2&#x27;</span>)<br>    langs = [each.find(<span class="hljs-string">&quot;span&quot;</span>,attrs=&#123;<span class="hljs-string">&quot;itemprop&quot;</span>: <span class="hljs-string">&quot;programmingLanguage&quot;</span>&#125;) <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> langsdiv]<br>    langs = [each.text <span class="hljs-keyword">if</span> each <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;None&quot;</span> <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> langs]<br>    snfs = [each.find_all(<span class="hljs-string">&quot;a&quot;</span>,class_=<span class="hljs-string">&quot;Link--muted mr-3&quot;</span>) <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> langsdiv]<br>    stars = [each[<span class="hljs-number">0</span>].text.strip().replace(<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> snfs]<br>    forks = [<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(each)==<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> each[<span class="hljs-number">1</span>].text.strip().replace(<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> snfs]<br>    temp = [each.find(<span class="hljs-string">&quot;p&quot;</span>) <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> search_field.findAll(<span class="hljs-string">&quot;div&quot;</span>, class_=<span class="hljs-string">&#x27;py-1&#x27;</span>)]<br>    descriptions = [each.text.strip().replace(<span class="hljs-string">&quot;\n&quot;</span>,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-keyword">if</span> each <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;Woops! there is No description about this project&quot;</span> <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> temp]<br>    base_url = <span class="hljs-string">&quot;https://github.com&quot;</span><br>    links = [base_url+each.find(<span class="hljs-string">&quot;a&quot;</span>)[<span class="hljs-string">&#x27;href&#x27;</span>] <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> search_field.findAll(<span class="hljs-string">&quot;h3&quot;</span>)]<br>    names = [each.split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> links]<br>    update_time = [each.get(<span class="hljs-string">&quot;datetime&quot;</span>) <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> search_field.findAll(<span class="hljs-string">&quot;relative-time&quot;</span>)]<br>    <span class="hljs-keyword">return</span> [&#123;<span class="hljs-string">&quot;RepoName&quot;</span>:name, <span class="hljs-string">&quot;Description&quot;</span>:des, <span class="hljs-string">&quot;Link&quot;</span>: link, <span class="hljs-string">&quot;Language&quot;</span>:lang, <span class="hljs-string">&quot;Star&quot;</span>:star, <span class="hljs-string">&quot;Fork&quot;</span>:fork, <span class="hljs-string">&quot;UpdateTime&quot;</span>: update&#125;<span class="hljs-keyword">for</span> name, des, link, lang, star, fork, update <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(names, descriptions, links, langs, stars, forks, update_time)]<br></code></pre></td></tr></table></figure><p>但是这只能处理单页30个仓库的数据，后面几页还需要定位到下方的<code>Next</code>按钮获取下一页的数据：</p><p><img src="https://s2.loli.net/2025/01/26/AqSDB3sVI6F8dGK.png" alt="古法爬虫获取"></p><p>所以还要写一个递归获取所有页数据的函数。我偷懒了，直接用Cline+DeepSeekV2.5写的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_next</span>(<span class="hljs-params">base_url: <span class="hljs-built_in">str</span>, </span><br><span class="hljs-params">             max_depth: <span class="hljs-built_in">int</span> = <span class="hljs-number">100</span>, </span><br><span class="hljs-params">             current_depth: <span class="hljs-built_in">int</span> = <span class="hljs-number">0</span>,</span><br><span class="hljs-params">             url_list: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    递归爬取所有URL</span><br><span class="hljs-string">    :param base_url: 当前要爬取的URL</span><br><span class="hljs-string">    :param max_depth: 最大递归深度，防止无限递归</span><br><span class="hljs-string">    :param current_depth: 当前递归深度</span><br><span class="hljs-string">    :param url_list: 存储所有URL的列表</span><br><span class="hljs-string">    :return: 包含所有URL的列表</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 初始化URL列表</span><br>    <span class="hljs-keyword">if</span> url_list <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        url_list = []<br>    <br>    <span class="hljs-comment"># 添加当前URL到列表</span><br>    url_list.append(base_url)<br>    <br>    <span class="hljs-keyword">if</span> current_depth &gt;= max_depth:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;达到最大递归深度 <span class="hljs-subst">&#123;max_depth&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> url_list<br><br>    <span class="hljs-keyword">try</span>:<br>        req = requests.get(base_url, headers=headers)<br>        req.raise_for_status()<br>        <br>        soup = BeautifulSoup(req.text, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>        search_field = soup.find(<span class="hljs-string">&quot;div&quot;</span>, class_=<span class="hljs-string">&quot;BtnGroup&quot;</span>)<br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> search_field:<br>            <span class="hljs-keyword">return</span> url_list<br>            <br>        urls = search_field.find_all(<span class="hljs-string">&quot;a&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;rel&quot;</span>: <span class="hljs-string">&quot;nofollow&quot;</span>&#125;)<br>        <br>        <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> urls:<br>            <span class="hljs-keyword">if</span> each.text == <span class="hljs-string">&quot;Next&quot;</span>:<br>                next_url = each.get(<span class="hljs-string">&quot;href&quot;</span>)<br>                <span class="hljs-comment"># print(f&quot;当前深度: &#123;current_depth&#125;, 找到下一个URL: &#123;next_url&#125;&quot;)</span><br>                <span class="hljs-keyword">return</span> find_next(base_url=next_url, <br>                              max_depth=max_depth,<br>                              current_depth=current_depth + <span class="hljs-number">1</span>,<br>                              url_list=url_list)<br>        <br>        <span class="hljs-keyword">return</span> url_list<br>        <br>    <span class="hljs-keyword">except</span> requests.RequestException <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;请求失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> url_list<br></code></pre></td></tr></table></figure><p>到目前为止，都很顺利！</p><h3 id="交互设计"><a href="#交互设计" class="headerlink" title="交互设计"></a>交互设计</h3><p>主要要对两个事件做处理：一个是数据的同步，一个是输入反馈。这里面我就做了一些简单的动画，例如使用了转圈的黄色来表示正在处理、红色表示出现异常，以及绿色表示操作成功：</p><p><img src="https://pic1.imgdb.cn/item/68750b1258cb8da5c8ad9855.gif" alt="同步交互"></p><p>结果的反馈则是渐进式的，以相对平滑的动画呈现搜索的结果。</p><p><img src="https://pic1.imgdb.cn/item/68750b1258cb8da5c8ad9862.gif" alt="搜索结果显示交互"></p><p>这里的文字显示还是有点小问题，不过后面会改的（</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="同步数据-数据入库"><a href="#同步数据-数据入库" class="headerlink" title="同步数据+数据入库"></a>同步数据+数据入库</h3><p>爬取数据那里我真感觉不对劲，Github这么大的使用量，难道真的没有对应的REST API吗？我于是狠狠地一个个点进去文档仔细找，还真给我找到了 ，<a href="https://docs.github.com/en/rest/activity/starring?apiVersion=2022-11-28#list-repositories-starred-by-a-user">🔗在这里</a>：</p><p><img src="https://s2.loli.net/2025/01/26/v42MFEXZ5H3RKhu.png" alt="image-20250126123019455"></p><p>这个支持分页，每页最多可以拉100条数据，在Github个人设置那里开启一个token就可以使用API了。接下来我们可以用异步来优化！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> aiohttp<br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> lxml<br>GITHUB_TOKEN=os.environ[<span class="hljs-string">&#x27;GITHUB_TOKEN&#x27;</span>]<br>GITHUB_USER=<span class="hljs-string">&#x27;karminski&#x27;</span> <span class="hljs-comment"># 用我的赛博知识启蒙师傅牙医老师的repo做测试</span><br>proxy = <span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span> <span class="hljs-comment"># 开发的时候由于国内的环境问题，需要使用科学上网手段；部署时可以去掉= =</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_params</span>(<span class="hljs-params">GITHUB_USER</span>):<br>    url = <span class="hljs-string">f&quot;https://github.com/<span class="hljs-subst">&#123;GITHUB_USER&#125;</span>?tab=stars&quot;</span><br>    req = requests.get(url, <br>                       headers=&#123;<span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36 Edg/132.0.0.0&quot;</span>,<span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>&#125;, <br>                       proxies=&#123;<span class="hljs-string">&quot;https&quot;</span>: <span class="hljs-string">&quot;127.0.0.1:7890&quot;</span>, <span class="hljs-string">&quot;http&quot;</span>: <span class="hljs-string">&quot;127.0.0.1:7890&quot;</span>&#125;<br>                       )<br>    soup=BeautifulSoup(req.text, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    stars_num = soup.find(<span class="hljs-string">&quot;a&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;aria-current&quot;</span>:<span class="hljs-string">&quot;page&quot;</span>&#125;).find(<span class="hljs-string">&quot;span&quot;</span>,class_=<span class="hljs-string">&quot;Counter&quot;</span>).get(<span class="hljs-string">&quot;title&quot;</span>).replace(<span class="hljs-string">&quot;,&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>    user_id = soup.find(<span class="hljs-string">&quot;a&quot;</span>, attrs=&#123;<span class="hljs-string">&quot;itemprop&quot;</span>: <span class="hljs-string">&quot;image&quot;</span>&#125;).get(<span class="hljs-string">&quot;href&quot;</span>).replace(<span class="hljs-string">&quot;https://avatars.githubusercontent.com/u/&quot;</span>,<span class="hljs-string">&#x27;&#x27;</span>)[:-<span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">return</span> user_id, <span class="hljs-built_in">int</span>(stars_num)//<span class="hljs-number">100</span>+<span class="hljs-number">1</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_with_</span>(<span class="hljs-params">url, headers, proxy</span>):<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, headers=headers, proxy=proxy) <span class="hljs-keyword">as</span> response:<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.json()<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_multiple_urls</span>(<span class="hljs-params">github_user, headers, proxy</span>):<br>    user_id, stars_num = get_params(github_user)<br>    urls = [<br>    <span class="hljs-string">f&quot;https://api.github.com/user/<span class="hljs-subst">&#123;user_id&#125;</span>/starred?per_page=100&amp;page=<span class="hljs-subst">&#123;i&#125;</span>&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, stars_num+<span class="hljs-number">1</span>)<br>]<br>    tasks = [fetch_with_(url, headers, proxy) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls]<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> asyncio.gather(*tasks)<br><br><br>headers = &#123;<br>    <span class="hljs-string">&quot;Accept&quot;</span>: <span class="hljs-string">&quot;application/vnd.github+json&quot;</span>,<br>    <span class="hljs-string">&quot;Authorization&quot;</span>: <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;GITHUB_TOKEN&#125;</span>&quot;</span>,<br>    <span class="hljs-string">&quot;X-GitHub-Api-Version&quot;</span>: <span class="hljs-string">&quot;2022-11-28&quot;</span>,<br>&#125;<br><br><span class="hljs-comment"># 运行异步任务并打印结果</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    results = <span class="hljs-keyword">await</span> fetch_multiple_urls(GITHUB_USER, headers, proxy)<br>    results = [subitem <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> results <span class="hljs-keyword">for</span> subitem <span class="hljs-keyword">in</span> item]<br>    <span class="hljs-keyword">return</span> results<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> time<br>    st = time.time()<br>    <span class="hljs-comment"># 这里学到一些怎么把异步结果拉到同步里面执行的操作</span><br>    loop = asyncio.get_event_loop()<br>    task = loop.create_task(main())<br>    loop.run_until_complete(task)<br>    results = task.result()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(results))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Time cost:<span class="hljs-subst">&#123;time.time() - st&#125;</span> seconds&quot;</span>)<br></code></pre></td></tr></table></figure><p>在<code>benchmark.py</code>中有一个同步和异步对比的结果，感兴趣的可以自己根据情况注释掉proxy后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python benchmark.py <br>Using Sync method to get results now...<br>All Sync results len: 2394<br>Sync Time Cost:63.70227098464966 seconds<br>Using Async method to get results now...<br>All Async results len: 2394<br>Async Time Cost:3.307866334915161 seconds<br></code></pre></td></tr></table></figure><p>考虑一下Vercel里面的默认超时是10s，这个的含金量希望你也能懂~</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>我使用的是<a href="https://console.upstash.com/vector?teamid=0">Vector - Upstash</a>的向量数据库。按照使用指引可以非常非常方便地进行配置。你可以参考我的向量数据库配置：</p><p><img src="https://s2.loli.net/2025/01/26/UYIBaNpPj7AmH5t.png" alt="image-20250126182128256"></p><p>我使用了BAAI的bge-m3模型作为Embedding的工具。Upstash的<a href="https://github.com/upstash/vector-py">Python-SDK</a>提供了很简单的增删改查的样例:</p><h3 id="向量数据入库"><a href="#向量数据入库" class="headerlink" title="向量数据入库"></a>向量数据入库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> upstash_vector <span class="hljs-keyword">import</span> Index, Vector<br><br>index = Index(url=<span class="hljs-string">&quot;https://YOUR-vector.upstash.io&quot;</span>, token=<span class="hljs-string">&quot;YOUR_TOKEN&quot;</span>)<br><br>index.upsert(<br>  vectors=[<br>    Vector(<br>      <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;id1&quot;</span>,<br>      data=<span class="hljs-string">&quot;Enter data as string&quot;</span>,<br>      metadata=&#123;<span class="hljs-string">&quot;metadata_field&quot;</span>: <span class="hljs-string">&quot;metadata_value&quot;</span>&#125;,<br>    )<br>  ]<br>)<br><br>index.query(<br>  data=<span class="hljs-string">&quot;Enter data as string&quot;</span>,<br>  top_k=<span class="hljs-number">1</span>,<br>  include_vectors=<span class="hljs-literal">True</span>,<br>  include_metadata=<span class="hljs-literal">True</span>,<br>)<br></code></pre></td></tr></table></figure><p>只需要稍加修改就可以使用<code>database.upsert()</code>方法把爬取到的Github星标数据入库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&quot;/asyncupdate&quot;</span></span>)</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">asyncupdate</span>():<br><span class="hljs-comment"># ....</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">for</span> cindex, each <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(chunk_list):<br>            vectors = [<br>                (<span class="hljs-string">f&quot;id<span class="hljs-subst">&#123;cindex*<span class="hljs-number">1000</span> + index+<span class="hljs-number">1</span>&#125;</span>&quot;</span>,<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;value[<span class="hljs-string">&#x27;full_name&#x27;</span>]&#125;</span>: <span class="hljs-subst">&#123;value[<span class="hljs-string">&#x27;description&#x27;</span>]&#125;</span>&quot;</span>,value) <span class="hljs-keyword">for</span> index,value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(each)<br>            ]<br>            vecdb_res = database.upsert(<br>                    vectors=vectors<br>                )<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[Upstash] Upload data to vecdb: <span class="hljs-subst">&#123;vecdb_res&#125;</span>.&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;res&quot;</span>:vecdb_res,<span class="hljs-string">&quot;len&quot;</span>:<span class="hljs-built_in">len</span>(results)&#125;<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(e)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;res&quot;</span>: <span class="hljs-string">&quot;[Vecdb] Error Indexing data.&quot;</span>&#125;<br>    <br>    <span class="hljs-comment"># return &#123;&quot;RepoNums&quot;: len(vectors)&#125;</span><br></code></pre></td></tr></table></figure><h3 id="删除脏数据"><a href="#删除脏数据" class="headerlink" title="删除脏数据"></a>删除脏数据</h3><p>当然，如果不小心放了一些脏数据进去，也可以这样根据入库时候的id范围进行删除：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> upstash_vector <span class="hljs-keyword">import</span> Index,Vector<br><span class="hljs-keyword">import</span> os<br><br>GITHUB_USER=os.environ[<span class="hljs-string">&#x27;GITHUB_USER&#x27;</span>]<br>GITHUB_TOKEN=os.environ[<span class="hljs-string">&#x27;GITHUB_TOKEN&#x27;</span>]<br>database_token=os.environ[<span class="hljs-string">&#x27;DATABASE_TOKEN&#x27;</span>]<br>database_url=os.environ[<span class="hljs-string">&quot;DATABASE_URL&quot;</span>]<br><br>base_url = <span class="hljs-string">f&quot;https://github.com/<span class="hljs-subst">&#123;GITHUB_USER&#125;</span>?tab=stars&quot;</span><br>index = Index(url=database_url, token=database_token)<br>res = index.delete(<br>    ids=[<span class="hljs-string">f&quot;id<span class="hljs-subst">&#123;i&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">120</span>)]<br>)<br><br><span class="hljs-comment"># How many vectors are deleted out of the given ids.</span><br><span class="hljs-built_in">print</span>(res.deleted)<br></code></pre></td></tr></table></figure><h2 id="完工！"><a href="#完工！" class="headerlink" title="完工！"></a>完工！</h2><p>完成的成果放在了<a href="https://stars-gazer.vercel.app/">vercel</a>上面啦！如果大家喜欢或者感兴趣的话，可以fork回去改一改来玩~</p>]]></content>
    
    
    <categories>
      
      <category>摸鱼产品</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
      <tag>RAG</tag>
      
      <tag>向量搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3D 打印相关记录</title>
    <link href="/3DPrinter-Records-1a7eeee67616/"/>
    <url>/3DPrinter-Records-1a7eeee67616/</url>
    
    <content type="html"><![CDATA[<h2 id="材料相关"><a href="#材料相关" class="headerlink" title="材料相关"></a>材料相关</h2><h3 id="PLA高精度打印"><a href="#PLA高精度打印" class="headerlink" title="PLA高精度打印"></a>PLA高精度打印</h3><p>在<a href="https://www.bilibili.com/video/BV17C411E7Hp">如何用FDM打印高质量手板模型</a>这个视频中，给出了PLA材料的高质量打印参数。</p><p>高细物体在龙门架结构的打印机中表现不佳。给出的打印参数如下：</p><ul><li><p>喷嘴温度：首层220°C，室温25°C下可设置为203°C</p></li><li><p>参数覆盖：</p><ul><li>回抽长度：1.6mm</li><li>回抽时抬升Z轴：0.4mm</li><li>Z轴抬升方式：螺旋</li><li>回抽速度：50mm&#x2F;s</li></ul></li><li><p>层高选项：0.12mm Fine@BBL A1</p></li></ul><p>如果要高精度+快速，可以开启可变层高功能：</p><ul><li><p>打印机设置：</p><ul><li>挤出机：层高限制设为<code>[0.08,0.12]</code> mm。</li><li>选中一个部件，选择切片软件上方可变层高菜单，选择自适应</li></ul></li><li><p>质量：</p><ul><li>接缝位置：背面，摆盘时把看不见的面摆到背面</li><li>高级：顶面单层 墙不使用</li></ul></li><li><p>强度：</p><ul><li>墙层数：3层</li><li>稀疏填充图案：螺旋体</li><li>稀疏填充密度：15%</li></ul></li><li><p>速度：</p><ul><li>加速度：外墙：1000mm&#x2F;s^2</li></ul></li><li><p>支撑：</p><ul><li>开启支撑，树状自动</li><li>顶部Z距离：0.07mm</li><li>主体图案线距：1.2mm</li><li>顶部接触面层数：5层</li><li>支撑面图案：交叠的直线</li><li>顶部接触面线距：0.4mm</li><li>支撑独立层高：不勾选</li></ul></li></ul><h3 id="毛绒表面"><a href="#毛绒表面" class="headerlink" title="毛绒表面"></a>毛绒表面</h3><p>使用了 <a href="https://makerworld.com.cn/zh/models/128405?from=search#profileId-18986">《电锯人》中的波奇塔</a> 的模型，开启了毛绒表面。但是由于这种组合件的接触部分也会被识别为表面，所以需要在组合件的接触面增加一个修改器，将修改器的表面尽可能地去贴合组合件的表面，并针对该修改器对象关闭毛绒表面。这是我使用0.4mm层高打印出来的波奇塔~</p><p><img src="/imgs/Pochita.jpg" alt="with BambuA1@0.4mm"></p><p>太可爱了，但是组合都还是差了一点。要么把比例缩小试一下，或许能解决这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>摸鱼娱乐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D打印</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
